{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Manejo de Errores</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="../../static/css/manejoErrores.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<style>
		table, th, td {
			border: 1px solid black;
		}
		footer {
			background-color: #364552;
			padding: 3rem;
			color: #efefef;
		}
		footer section {
			float: right;
		}
		footer p {
			margin: 0;
		}
		footer a {
			transition: color 0.3s ease;
			color: #efefef;
			text-decoration: none;
		}
		footer a:hover {
			color: cornflowerblue;
		}
	</style>
</head>
<body>
	<header>
		<h1>Manejo de Errores</h1>
	</header>
	<section>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Errores y excepciones</h2>
				<p>
					En algunas ocasiones nuestros programas pueden fallar ocasionando su detención.
				</p>
				<p>
					Ya sea por <strong>errores de sintaxis o de lógica</strong>, tenemos que ser capaces de detectar esos <br>
					momentos y tratarlos debidamente para prevenirlos.
				</p>
				<ul>
					<img src="{% static 'img/parablog101.jpg'%}" alt="Info-Python-blog" height="400px">
				</ul>
			</center>
		</article>
		<hr>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Errores</h2>
				<p>
					Los <strong>errores</strong> detienen la ejecución del programa y tienen varias causas. <br><br>
					Para poder estudiarlos mejor vamos a provocar algunos intencionadamente.
				</p>
				<h3 style="color: cornflowerblue;">Errores de sintaxis</h3>
				<p>
					Indentificados con el código <strong style="color: red;">SyntaxError</strong>, son los que podemos apreciar repasando <br>
					el código, por ejemplo al olvidarnos de cerrar un paréntesis:
				</p>
				<br>
				<table style="width: 30%;">
					<tr>
						<th>
							<strong>Código</strong>
						</th>
					</tr>
					<tr>
						<td>
							print("Hola"
						</td>
					</tr>
					<tr>
						<th>
							<strong>Resultado</strong>
						</th>
					</tr>
					<tr>
						<td>
							File " ipython-input-1-8bc9f5174855>", line 1 
							<ul>
								print("Hola" 
								<ul>
									^ 
								</ul>	
							</ul>
							SyntaxError: unexpected EOF while parsing
						</td>
					</tr>
				</table>
			</center>
			<br>
		</article>
		<hr>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Errores de nombre</h3>
				<p>
					Se producen cuando el sistema interpreta que debe ejecutar alguna función, método... pero no <br>
					lo encuentra definido. Devuelven el código <strong style="color: red;">NameError</strong>:
				</p>
				<br>
				<table style="width: 30%;">
					<tr>
						<th>
							<strong>Código</strong>
						</th>
					</tr>
					<tr>
						<td>
							pint("Hola")
						</td>
					</tr>
					<tr>
						<th>
							<strong>Resultado</strong>
						</th>
					</tr>
					<tr>
						<td>
							ipython-input-2-155163d628c2> in module>()
							<ul>
								----> 1 pint("Hola")
							</ul>
							NameError: name 'pint' is not defined
						</td>
					</tr>
				</table>
			</center>
		</article>
		<hr>
		<article class="post">
			<center>
				<p>
					La mayoría de errores sintácticos y de nombre los identifican los editores de código <br>
					antes de la ejecución, pero existen otros tipos que pasan más desapercibidos.
				</p>
				<h3 style="color: cornflowerblue;">Errores semánticos</h3>
				<p>
					Estos errores son muy dificíles de identificar porque van ligados al sentido del funcionamiento y <br>
					dependen de la situación. <strong>Algunas veces pueden ocurrir y otras no.</strong>
				</p>
			</center>
			<ul>
				<ul>
					<img src="{% static 'img/parablog102.jpg'%}" class="left" alt="Info-Python-blog" height="400px">
				</ul>
				<br>
				<p>	
					<strong>
						La mejor forma de prevenirlos es programando mucho <br>
						y aprendiendo de tus propios fallos, la experencia <br>
						es clave.
					</strong>
				</p>
				<br><br>
				<p>
					Veamos un par de ejemplos: <br>
					<strong>Ejemplo pop() con lista vacía</strong><br>
					Si intentamos sacar un elemento de una lista vacía, el programa dará fallo de tipo <strong style="color: red;">IndexError</strong>. <br>
					Esta situación ocurre <strong>sólo durante la ejecución</strong> del programa, por lo que los editores no lo detectarán: <br>
				</p>
				<ul>
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								l = [] <br>
								l.pop()
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								ipython-input-6-9e6f3717293a> in module>() <br>
								----> 1 l.pop() <br>
								IndexError: pop from empty list
							</td>
						</tr>
					</table>
				</ul>
				<br>
				<p>
					<strong style="color: black;">Ejemplo lectura de cadena y operación sin conversión a número</strong><br>
					Cuando leemos un valor con la función <strong>input()</strong>, éste siempre se obtendrá como una cadena de <br>
					caracteres. Si intentamos operarlo directamente con otros números tendremos un fallo <br>
					<strong style="color: red;">TypeError</strong> que tampoco detectan los editores de código:
				</p>
				<ul>
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								n = input("Introduce un número: ") <br>
								print("{}/{} = {}".format(n,m,n/m))
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								Introduce un número: 4 <br><br>
								---------------------------------------------------------------------- <br>
								TypeError		Traceback (most recent call last) <br>
								ipython-input-12-85bb893ab3e3> in module>() <br>
								----> 1 print("{}/{} = {}".format(n,m,n/m)) <br><br>
								TypeError: unsupported operand type(s) for /: 'str' and 'int'
							</td>
						</tr>
					</table>
				</ul>
				<br>
				<p>
					Como ya sabemos este error se puede prevenir transformando la cadena a entero o flotante: <br>
				</p>
				<ul>
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								n = float(input("Introduce un número: ")) <br>
								m = 4 <br>
								print("{}/{} = {}".format(n,m,n/m)) 
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								Introduce un número: 10 <br>
								10.0/4 = 2.5
							</td>
						</tr>
					</table>
				</ul>
				<br>
				<p>
					Sin embargo no siempre se puede prevenir, como cuando se introduce una cadena que no es un <br>
					número:
				</p>
				<br>
				<ul>
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								n = float(input("Introduce un número: ")) <br>
								m = 4 <br>
								print("{}/{} = {}".format(n,m,n/m))
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								Introduce un número: aaa <br>
								--------------------------------------------------------------------------- <br>
								ValueError Traceback (most recent call last) <br>
								ipython-input-14-c0e7fd4a26a9> in module>() <br>
								----> 1 n = float(input("Introduce un número: "))
								<ul>
									2 m = 4 <br>
									3 print("{}/{} = {}".format(n,m,n/m))
								</ul>
								ValueError: could not convert string to float: 'aaa' 
							</td>
						</tr>
					</table>
				</ul>
				<br>
				<p>
					Como se puede observar, es difícil prevenir fallos que ni siquiera nos habíamos planteado que <br>
					podían existir.
				</p>
				<br>
			</ul>
			<center>
				<h3>Por suerte para esas situaciones existen las excpciones.</h3>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Excepciones</h2>
				<p>
					Las <strong>excepciones</strong> son bloques de código que <strong>nos permiten continuar con la ejecución de un 
					programa</strong> pese a que ocurra un error. <br><br>
					Siguiendo con el ejemplo anterior, teníamos el caso en que leíamos un número por teclado, pero <br>
					el usuario no introducía un número: <br><br>
					<h3 style="color: blueviolet;">Bloques try - except</h3><br>
					Para prevenir el fallo debemos poner el código propenso a errores en un <strong>bloque try</strong> y luego <br>
					encadenar un bloque <strong>except</strong> para tratar la situación excepcional mostrando que ha ocurrido un <br>
					fallo:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							try:
							<ul>
								n = float(input("Introduce un número: ")) <br>
								m = 4 <br>
								print("{}/{} = {}".format(n,m,n/m))
							</ul>
							except:
							<ul>
								print("Ha ocurrido un error, introduce bien el número")
							</ul>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Introduce un número: aaa <br>
							Ha ocurrido un error, introduce bien el número
						</td>
					</tr>
				</table>
				<p>
					Como vemos esta forma nos permite controlar situaciones excepcionales que generalmente <br>
					darían error y en su lugar mostrar un mensaje o ejecutar una pieza de código alternativo. <br><br>
					Podemos aprovechar las excepciones para forzar al usuario a introducir un número haciendo uso <br>
					de un <strong>bucle while</strong>, repitiendo la lectura por teclado hasta que lo hagan bien y entonces <br>
					romper el bucle con un <strong>break:</strong>
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							while(True):
							<ul>
								try:
								<ul>
									n = float(input("Introduce un número: ")) <br>
									m = 4 <br>
									print("{}/{} = {}".format(n,m,n/m)) <br>
									break # Importante romper la iteración si todo ha salido bien
								</ul>
								except: 
								<ul>
									print("Ha ocurrido un error, introduce bien el número")
								</ul>
							</ul>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Introduce un número: aaa <br>
							Ha ocurrido un error, introduce bien el número <br>
							Introduce un número: sdsdsd <br>
							Ha ocurrido un error, introduce bien el número <br>
							Introduce un número: sdsdsd <br>
							Ha ocurrido un error, introduce bien el número <br>
							Introduce un número: sdsd <br>
							Ha ocurrido un error, introduce bien el número <br>
							Introduce un número: 10 <br>
							10.0/4 = 2.5
						</td>
					</tr>
				</table>
				<br>
				<p>
					<h3 style="color: blueviolet;">Bloque else</h3><br>
					Es posible encadenar un <strong>bloque else</strong> después del <strong>except</strong> para comprobar el caso en que todo <br>
					funcione correctamente (no se ejecuta la excepción). <br><br>
					El <strong>bloque else</strong> es un buen momento para romper la iteración con break si todo  funciona <br>
					correctamente:
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							while(True):
							<ul>
								try:
								<ul>
									n = float(input("Introduce un número: ")) <br>
									m = 4 <br>
									print("{}/{} = {}".format(n,m,n/m))
								</ul>
								except:
								<ul>
									print("Ha ocurrido un error, introduce bien el número")
								</ul>
								else: 
								<ul>
									print("Todo ha funcionado correctamente") <br>
									break # Importante romper la iteración si todo ha salido bien
								</ul>
							</ul>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Introduce un número: 10 <br>
							10.0/4 = 2.5 <br>
							Todo ha funcionado correctamente
						</td>
					</tr>
				</table>
				<br>
				<p>
					<h3 style="color: blueviolet;">Bloque finally</h3><br>
					Por último es posible utilizar un <strong>bloque finally</strong> que se ejecute al final del código, ocurra o no <br>
					un error:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							while(True):
							<ul>
								try:
								<ul>
									n = float(input("Introduce un número: ")) <br>
									m = 4 <br>
									print("{}/{} = {}".format(n,m,n/m))
								</ul>
								except: 
								<ul>
									print("Ha ocurrido un error, introduce bien el número")
								</ul>
								else: 
								<ul>
									print("Todo ha funcionado correctamente") <br>
									break # Importante romper la iteración si todo ha salido bien
								</ul>
								finally: 
								<ul>
									print("Fin de la iteración") # Siempre se ejecuta
								</ul>
							</ul>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Introduce un número: aaa
							Ha ocurrido un error, introduce bien el número <br>
							Fin de la iteración <br>
							Introduce un número: 10 <br>
							10.0/4 = 2.5 <br>
							Todo ha funcionado correctamente <br>
							Fin de la iteración
						</td>
					</tr>
				</table>
			</center>
		</article>
		<br>
		<article class="post">
			<center>
				<h3 style="color: blueviolet;">Excepciones múltiples</h3>
				<p>
					Es una misma pieza de código pueden ocurrir muchos errores distintos y quizá nos interese <br>
					actuar de forma diferente en cada caso. <br><br>
					Para esas situaciones algo que podemos hacer es asignar una excepción a una variable. <br><br>
					De esta forma es posible analizar el tipo de error que sucede gracias a su identificador:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							try:
							<ul>
								n = input("Introduce un número: ") # no transformamos a número <br>
								5/n
							</ul>
							except Exception as e: # guardamos la excepción como una variable e 
							<ul>
								print("Ha ocurrido un error =>", type(e).__name__)
							</ul>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Introduce un número: 10 <br>
							Ha ocurrido un error => TypeError
						</td>
					</tr>
				</table>
				<br>
				<p>
					Gracias a los identificadores de errores podemos crear múltiples comprobaciones, siempre que <br>
					dejamos en último lugar la excepción por defecto Excepción que engloba cualquier tipo de error <br>
					(si la pusiéramos al principio las demás excepciones nunca se ejecutarán):
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							try:
							<ul>
								n = float(input("Introduce un número divisor: ")) <br>
								5/n
							</ul>
							except TypeError:
							<ul>
								print("No se puede dividir el número entre una cadena")
							</ul>
							except ValueError:
							<ul>
								print("Debes introducir una cadena que sea un número")
							</ul>
							except ZeroDivisionError:
							<ul>
								print("No se puede dividir por cero, prueba otro número")
							</ul>
							except Exception as e:
							<ul>
								print("Ha ocurrido un error no previsto", type(e).__name__ )
							</ul>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Introduce un número divisor: 0 <br>
							No se puede dividir por cero, prueba otro número
						</td>
					</tr>
				</table>
			</center>
		</article>
		<br>
		<article class="post">
			<center>
				<h3 style="color: blueviolet;">Invocación de excepciones</h3>
				<p>
					En algunas ocasiones quizá nos interesa llamar un <strong>error manualmente</strong>, ya que un <strong>print</strong><br>
					común no es muy elegante. Para ello existe una palabra reservada llamada <strong>raise</strong> con la cual <br>
					podemos lanzar un error manual pasándole el identificador.} <br><br>
					Luego simplemente podemos añadir un <strong>except</strong> para tratar esta excepción que hemos lanzado:
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							def mi_funcion(algo=None):
							<ul>
								tyr:
								<ul>
									if algo is None: 
									<ul>
										raise ValueError("Error! No se permite un valor nulo")
									</ul>
								</ul>
								except ValueError:
								<ul>
									print("Error! No se permite un valor nulo (desde la excepción)")
								</ul>
							</ul>
							<br>
							mi_funcion()
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Error! No se permite un valor nulo (desde la excepción)
						</td>
					</tr>
				</table>
				<br><br>
			</center>
		</article>
	</section>
	<footer>
		<section>
			<a href="#">Ir al comienzo</a>
		</section>
	</footer>
</body>
</html>