{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Programacion Orientada a Objetos (POO)</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="../../static/css/poo.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<style>
		table, th, td {
			border: 1px solid black;
		}
	</style>
</head>
<body>
	<header>
		<h1>Programacion Orientada a Objetos (POO)</h1>
	</header>
	<section>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Paradigma de Programación Orientada a Objetos</h2>
				<p>
					Un <strong>paradigma</strong> es el resultado de un proceso social en el cual un grupo <br>
					de personas desarrolla nuevas ideas y crea principios y prácticas alrededor de estas ideas.
				</p>
				<img src="{% static 'img/parablog103.jpg'%}" alt="Info-Python-blog" height="450px"><br>
				<p>
					En programación, se trata de un enfoque concreto de desarrollar y estructurar el desarrollo <br>
					de programas en base a Objetos.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Clase</h3>
				<p>
					Una <strong>clase es un modelo que define las propiedades y comportamiento de un tipo de objeto <br>
					concreto</strong>, en la instanciación se hace la lectura de estas definiciones y se crea un objeto a partir <br>
					de ellas. Las clases son abstracciones que representan a un conjunto de objetos con un comportamiento e interfaz <br>
					común. <br><br>
					Una clase se compone de dos partes:
					<ul>
						<li><strong>Atributos>:</strong> esto es, los datos que se refieren al estado del objeto.</li>
						<li><strong>Métodos:</strong> son funciones que pueden aplicarse a objetos.</li>
					</ul>
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Objeto</h3>
				<p>
					<strong>Entidad provista de un conjunto de propiedades o atributos (datos) y de comportamiento o <br>
					funcionalidad (métodos),</strong> los mismos que consecuentemente reaccionan a eventos. Se corresponden <br>
					con los objetos reales del mundo que nos rodea, o con objetos internos del sistema (del programa). <br>
					En realidad, un objeto es una instancia de una clase, por lo que se pueden intercambiar los términos objeto o <br>
					instancia. Un ejemplo de objeto podría ser un automóvil, en el que tendríamos atributos como la marca, el <br>
					número de puertas o el color y métodos como arrancar y parar. O bien cualquier otra combinación de atributos y <br>
					métodos según lo que fuera relevante para nuestro programa. <br><br>
					Un objeto consta de:
					<ul>
						<li>
							<strong>Tiempo de vida:</strong> La duración de un objeto en un programa siempre está limitada en el <br>
							tiempo. La mayoría de los objetos son creados mediante un mecanismo denominado instanciación, <br>
							y cuando dejan de existir se dice que son destruidos.
						</li>
						<li>
							<strong>Estado:</strong> Todo objeto posee un estado, definido por sus atributos. Con él se definen las <br>
							propiedades del objeto, y el estado en que se encuentra en un momento determinado de su exitencia.
						</li>
						<li>
							<strong>Comportamiento:</strong> Todo objeto ha de presentar una interfaz, definida por sus métodos, <br>
							para que el resto de objetos que componen los programas puedan interactuar con él.
						</li>
						<li>
							<strong>Identidad:</strong> Propiedad del objeto que lo distingue de los demás. 
						</li>
					</ul>
				</p>
				<p>
					<strong>
						El equivalente de un objeto en el paradigma estructurado sería una variable. Así mismo la <br>
						instanciación de objetos equivaldría a la declaración de variables, y el tiempo de vida de un <br>
						objeto al ámbito* de una variable.
					</strong><br><br>
					*La zona del programa en la que una variable puede ser utilizada es lo que se conoce como su ámbito de <br>
					una variable local está limitado al código de la función en la que está definida.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<img src="{% static 'img/parablog104.jpg'%}" alt="Info-Python-blog" height="450px"><br><br>
				<p>
					Para modelar soluciones usuando Paradigma orientado a Objetos, comúnmente se utilizan los <br>
					<strong>Diagramas de Clases</strong>, es uno de los diagramas includios en UML 2.5 clasificado dentro de los <br>
					diagramas de estructura y, como tal, se utiliza para representar los elementos que componen un <br>
					sistema de información desde un punto de vista estático. 
				</p>
				<br>
				<img src="{% static 'img/parablog105.jpg'%}" alt="Info-Python-blog" height="450px">
				<br><br>
				<p>
					En Python las clases se definen mediante la palabra clave <strong>class</strong> seguida del nombre de la clase, <br>
					dos puntos (:) y a continuación, indentado, el cuerpo de la clase.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Persona con sus métodos y atributos. <br><br>
							<strong style="color: orange;">class</strong> Persona:
							<ul>
								<strong style="color: orange;">def __init__</strong> (self, nombre, edad, genero, estatura, peso):
								<ul>
									<strong style="color: yellow;">self</strong>.nombre = nombre <br>
									<strong style="color: yellow;">self</strong>.edad = edad <br>
									<strong style="color: yellow;">self</strong>.genero = genero <br>
									<strong style="color: yellow;">self</strong>.estatura = estatura <br>
									<strong style="color: yellow;">self</strong>.peso = peso
								</ul>
								<strong style="color: orange;">def</strong> hablar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Hola soy {}"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> correr(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta corriendo"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> caminar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta caminando"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					El método <strong>__init__</strong>, con una doble barra baja al principio y al final del nombre, se ejecuta justo <br>
					después de crear un nuevo objeto a partir de la clase, proceso que se conoce con el nombre de instanciación. El método <br>
					<strong>__init__</strong> sirve, como sugiere su nombre, para realizar cualquier proceso de inicialización que sea necesario <br>
					como puede ser la asiganación de valores a atributos, cálculos, llamadas a otras funciones o procedimientos.
				</p>
				<p>
					Como vemos el primer parámetro de <strong>__init__</strong> y del resto de métodos de la clase es siempre <strong>self</strong><br>
					que sirve para referirse al objeto actual. <br>
					Este mecanismo es necesario para poder acceder a los atributos y métodos del objeto diferenciando, <br>
					por ejemplo, una variable local <strong>mi_var</strong> de un atributo del objeto <strong>self.mi_var.</strong>
				</p>
				<p>
					Si volvemos al método <strong>__init__</strong> de nuestra clase Persona véremos como se utiliza <strong>self</strong> para <br>
					asignar al atributo nombre del objeto (<strong>self.nombre</strong>) el valor que el programador especifica para <br>
					el párametro nombre. El parámetro nombre se destruye al final de la función, mientras que el atributo nombre se conserva <br>
					(y puede ser accedido) mientras el objeto viva.
				</p>
				<p>
					Para crear un objeto se escribiría el nombre de la clase seguido de cualquier parámetro que sea necesario <br>
					entre paréntesis. Estos parámetros son los que se pasarán al método <strong>__init__</strong>, que como <br>
					decíamos es el método que se llama al instanciar la clase.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Persona con sus métodos y atributos y crear objetos a partir de ella. <br><br>
							<strong style="color: orange;">class</strong> Persona:
							<ul>
								<strong style="color: orange;">def __init__</strong>(self, nombre, edad, sexo, estatura, peso):
								<ul>
									<strong style="color: yellow;">self</strong>.nombre = nombre <br>
									<strong style="color: yellow;">self</strong>.edad = edad <br>
									<strong style="color: yellow;">self</strong>.sexo = sexo <br>
									<strong style="color: yellow;">self</strong>.estatura = estatura <br>
									<strong style="color: yellow;">self</strong>.peso = peso
								</ul>
								<strong style="color: orange;">def</strong> hablar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Hola soy {}"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> correr(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta corriendo"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> caminar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta caminando"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
							</ul>
							<br>
							persona1 = <strong>Persona(<strong style="color: green;">"Juan"</strong>, <strong style="color: red;">23</strong>, <strong style="color: green;">"Masculino"</strong>, <strong style="color: red
							;">170</strong>, <strong style="color: red;">90</strong>)</strong><br>
							persona2 = <strong>Persona(<strong style="color: green;">"Maria"</strong>, <strong style="color: red;">25</strong>, <strong style="color: green;">"Femenino"</strong>, <strong style="color: red
							;">160</strong>, <strong style="color: red;">70</strong>)</strong>
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el ejemplo podemos ver que aunque la definición de la función indica claramente que <br>
					precisa de seis parámetros (self, nombre, edad, sexo, estatura y peso), a la hora de crear un objeto <br>
					de esta clase pasaremos solo cinco parámetros. Esto es así por que Python pasa el primer argumento <br>
					(la referencia al objeto que se crea) automáticamente. <br><br>
					Ahora que ya hemos creado nuestros objetos, podemos acceder a sus atributos y métodos <br>
					mediante la sintaxis <strong>objeto.atributo</strong> y <strong>objeto.método():</strong>
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Persona con sus métodos y atributos y crear un objeto y acceder a sus métodos y atributos. <br><br>
							<strong style="color: orange;">class</strong> Persona:
							<ul>
								<strong style="color: orange;">def __init__</strong>(self, nombre, edad, sexo, estatura, peso):
								<ul>
									<strong style="color: yellow;">self</strong>.nombre = nombre <br>
									<strong style="color: yellow;">self</strong>.edad = edad <br>
									<strong style="color: yellow;">self</strong>.sexo = sexo <br>
									<strong style="color: yellow;">self</strong>.estatura = estatura <br>
									<strong style="color: yellow;">self</strong>.peso = peso
								</ul>
								<strong style="color: orange;">def</strong> hablar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Hola soy {}"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> correr(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta corriendo"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> caminar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta caminando"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
							</ul>
							<br>
							persona1 = <strong>Persona(<strong style="color: green;">"Juan"</strong>, <strong style="color: red;">23</strong>, <strong style="color: green;">"Masculino"</strong>, <strong style="color: red
							;">170</strong>, <strong style="color: red;">90</strong>)</strong><br>
							persona2 = <strong>Persona(<strong style="color: green;">"Maria"</strong>, <strong style="color: red;">25</strong>, <strong style="color: green;">"Femenino"</strong>, <strong style="color: red
							;">160</strong>, <strong style="color: red;">70</strong>)</strong><br><br>
							<strong style="color: blue;">print</strong>(persona1.nombre) <br>
							<strong style="color: blue;">print</strong>(persona1.edad) <br>
							<strong style="color: blue;">print</strong>(persona1.sexo) <br>
							<strong style="color: blue;">print</strong>(persona1.estatura) <br>
							<strong style="color: blue;">print</strong>(persona1.peso) <br>
							persona1.<strong>hablar()</strong><br>
							persona1.<strong>correr()</strong><br>
							persona1.<strong>caminar()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Juan <br>
							23 <br>
							Masculino <br>
							170 <br>
							90 <br>
							Hola soy Juan <br>
							Juan está corriendo <br>
							Juan está caminando
						</td>
					</tr>
				</table>
				<br>
				<p>
					<strong>Clase:</strong> Persona <br>
					<strong>El objeto instanciado</strong> (creado a partir de esa clase): persona1
				</p>
				<table>
					<tr>
						<th>Atributos:</th>
						<th>Métodos:</th>
					</tr>
					<tr>
						<td>
							<ul>
								<li>nombre: "juan"</li>
								<li>edad: 23</li>
								<li>sexo:"Masculino"</li>
								<li>estatura: 170</li>
								<li>peso: 90</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>hablar()</li>
								<li>correr()</li>
								<li>caminar()</li>
							</ul>
						</td>
					</tr>
				</table>
			</center>
		</article>
		<br><br>
		<hr>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia</h2>
				<p>
					Hay tres conceptos que son básicos para cualquier lenguaje de programación orientada a objetos: <br>
					el <strong>encapsulamiento</strong>, la <strong>herencia</strong> y el <strong>polimorfismo</strong>.
				</p>
				<img src="{% static 'img/parablog106.jpg'%}" alt="Info-Python-blog" height="450px">
				<br>
				<p>
					En un lenguaje orientado a objetos cuando hacemos que una clase (subclase) <strong>herede</strong> de <br>
					otra clase (superclase) estamos haciendo que la subclase contenga todos los atributos y métodos que <br>
					tenía la superclase. <br>
					Al acto de heredar de una clase también se le llama a menudo "extender una clase".
				</p>
			</center>
		</article>
		<br>
		<hr>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia Simple</h2>
				<p>
					Supongamos que queremos modelar los instrumentos musicales de una banda, tendremos entonces una <br>
					<strong>clase Guitarra, una clase Batería, una clase Bajo</strong>, etc. Cada una de estas clases <br>
					tendrá una serie de atributos y métodos, pero ocurre que, por el hecho de ser instrumentos musicales, <br>
					estas clases compartirán muchos de sus atributos y métodos; un ejemplo sería el método <strong>tocar().</strong><br>
					Es más sencillo crear un tipo de objeto Instrumento con sus atributos y métodos comunes e indicar al programa que <br>
					Guitarra, Batería y Bajo son tipos de instrumentos, haciendo que hereden de Instrumento.
				</p>
			</center>
			<ul>
				<ul>
					<img src="{% static 'img/parablog107.jpg'%}" alt="Info-Python-blog" height="450px">
				</ul>
				<p>
					Para indicar que una clase hereda de otra se coloca el nombre de la clase que se hereda entre paréntesis después <br>
					del nombre de la clase:
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Instrumento con sus métodos y atributos y crear clases que hereden <br>
							de ella. <br><br>
							<strong style="color: red;">class</strong> Instrumento: 
							<ul>
								<strong style="color: red;">def __init__</strong>(self, precio):
								<ul>
									<strong style="color: orange;">self</strong>.precio = precio
								</ul>
								<strong style="color: red;">def</strong> tocar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Estamos tocando música"</strong>)
								</ul>
								<strong style="color: red;">def</strong> precio(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El precio de este instrumento es: $"</strong>, <strong style="color: orange;">self</strong>.precio)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Bateria(Instrumento):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<strong style="color: red;">class</strong> Guitarra(Instrumento):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					Como Bateria y Guitarra heredan de Instrumento, ambos tienen un método <strong>tocar()</strong> y un método <br>
					<strong>precio()</strong>, y se inicializan pasando un único parámetro, precio. Pero, ¿qué ocurriría si quisiéramos <br>
					especificar un nuevo parámetro <strong>tipo_cuerda</strong> a la hora de crear un objeto Guitarra?; bastaría con escribir <br>
					un nuevo método <strong>__init__</strong> para la clase Guitarra que se ejecutaría en lugar del <strong>__init__</strong> <br>
					de Instrumento. Esto es lo que se conoce como sobreescribir métodos.
				</p>
				<p>
					Ahora bien, puede ocurrir en algunos casos que necesitemos sobreescribir un método de la clase padre, pero que en ese <br>
					método queramos ejecutar el método de la clase padre porque nuestro nuevo método no necesite más que agregar un par de <br>
					instrucciones extra. En ese caso usamos la sintaxis <strong>SuperClase.metodo(self, args)</strong> para llamar al método <br>
					de igual nombre de la clase padre. Por ejemplo, para llamar al método <strong>__init__</strong> de Instrumento desde Guitarra <br>
					usaríamos <strong>Instrumento.__init__(self, precio).</strong>
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Instrumento con sus métodos y atributos y crear clases que <br>
							hereden de ella. <br><br>
							<strong style="color: red;">class</strong> Instrumento: 
							<ul>
								<strong style="color: red;">def __init__</strong>(self, precio):
								<ul>
									<strong style="color: orange;">self</strong>.precio = precio
								</ul>
								<strong style="color: red;">def</strong> tocar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Estamos tocando música"</strong>)
								</ul>
								<strong style="color: red;">def</strong> precio(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El precio de este instrumento es: $"</strong>, <strong style="color: orange;">self</strong>.precio)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Bateria(Instrumento):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<strong style="color: red;">class</strong> Guitarra(Instrumento):
							<ul>
								<strong style="color: red;">def __init__</strong>(self, tipo_cuerda, precio):
								<ul>
									<strong>Instrumento.</strong><strong style="color: red;">__init__</strong>(self, precio) <br>
									<strong style="color: orange;">self</strong>.tipo_cuerda = tipo_cuerda
								</ul>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					Observe que en este caso si es necesario especificar el parámetro <strong>self.</strong>
				</p>
			</ul>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia múltiple</h2>
				<p>
					En Python, a diferencia de otros lenguajes como Java o C#, se permite la herencia múltiple, es decir, una clase <br>
					puede heredar de varias clases a la vez. Por ejemplo, podríamos tener una clase Cocodrilo que heredara de la clase <br>
					Terrestre, con métodos como <strong>caminar()</strong> y atributos como <strong>velocidad_caminar</strong> y de la clase <br>
					Acuático, con métodos como <strong>nadar()</strong> y atributos como <strong>velocidad_nadar.</strong> Para indicar que una <br>
					clase hereda de múltiples clases basta con enumerar las clases de las que se hereda separándolas por comas:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el caso de que alguna de las clases padre tuvieran métodos con el mismo nombre y número de parámetros las clases <br>
					sobreescribirían la implementación de los métodos de las clases más a su derecha en la definición. <br>
					En el siguiente ejemplo, como Terrestre se encuentra más a la izquierda, sería la definición de <strong>desplazar()</strong> <br>
					de esta clase la que prevalecerá, y por lo tanto si llamamos al método desplazar de un objeto de tipo Cocodrilo lo que <br>
					se imprimiría sería "El animal anda".
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<br>
							c = <strong>Cocodrilo()</strong> <br>
							c<strong>.desplazar()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							El animal anda
						</td>
					</tr>
				</table>
				<br>
				<p>
					Lo mismo ocurre para el caso de constructor, en caso de que se requiera el uso de el constructor <br>
					de alguna clase específica puede usarse la sintaxis anteriormente vista, <strong>SuperClase.metodo(self, args).</strong>
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Terrestre"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Acuático"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<br>
							c = <strong>Cocodrilo()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Este es el constructor de la clase Terrestre
						</td>
					</tr>
				</table>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Terrestre"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Acuático"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong>Acuatico.</strong><strong style="color: red;">__init__</strong>(self)
								</ul>
							</ul>
							<br>
							c = <strong>Cocodrilo()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Este es el cosntructor de la clase Acuático
						</td>
					</tr>
				</table>
				<br><br>
				<p>
					En el segundo ejemplo se define cual de los constructores de las superclases se va a utilizar, permitiéndonos especificar <br>
					qué métodos usará de cada una de las clases padre sin importar quien esté más a su derecha en la definición de la clase.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia multinivel en Python</h2>
				<p>
					Por otro lado, también podemos heredar de una clase derivada. Esto se llama herencia multinivel y puede ser de cualquier <br>
					profundidad en Python. <br>
					En la herencia multinivel, las características de la clase base y la clase derivada se heredan en la nueva clase derivada.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							multinivel entre ellas. <br><br>
							<strong style="color: red;">class</strong> Figura: 
							<ul>
								<strong style="color: red;">def __init__</strong>(self, area):
								<ul>
									<strong style="color: orange;">self</strong>.area = area
								</ul>
								<strong style="color: red;">def</strong> retornar_area(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El área de la figura es: "</strong>, <strong style="color: orange;">self</strong>.area)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Poligono(Figura):
							<ul>
								<strong style="color: red;">def __init__</strong>(self, lados, area):
								<ul>
									<strong>Figura.</strong><strong style="color: red;">__init__</strong>(self, area) <br>
									<strong style="color: orange;">self</strong>.lados = lados
								</ul>
								<strong style="color: red;">def</strong> retornar_lados(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Los lados del poligono son: "</strong>, <strong style="color: orange;">self</strong>.lados)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cuadrilatero(Poligono):
							<ul>
								<strong style="color: red;">def __init__</strong>(self, area):
								<ul>
									<strong>Poligono.</strong><strong style="color: red;">__init__</strong>(self, <strong style="color: red;">4</strong>, area)
								</ul>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					Aquí por ejemplo, <strong>Poligono</strong> se deriva de <strong>Figura</strong>, y <strong>Cuadrilatero</strong> se deriva de <br>
					<strong>Poligono</strong> por lo que <strong>Cuadrilatero</strong> tendra los métodos y atributos tanto de las clase <strong>Poligono</strong><br>
					como de la clase <strong>Figura</strong>. Si en la clase <strong>Poligono</strong> alguno de los métodos de <strong>Figura</strong> es redefinido <br>
					<strong>Cuadrilatero</strong> heredara del método redfinido.
				</p>
				<br><br>
				<p>
					<strong>
						Nota: En el diseño de jerarquías de herencia no siempre es del todo fácil decidir cuándo una clase <br>
						debe extender a otra. La regla práctica para decidir si una clase (S) puede ser definida como heredera <br>
						de otra (T) es que debe cumplirse que "S es un T". Por ejemplo, Perro es una Animal, pero Vehiculo no es un Motor.
					</strong>
				</p>
			</center>
		</article>
		<br><br>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Método de resolución de orden en Python</h2>
				<p>
					Cada clase en Python se deriva de la clase <strong>object</strong>. Es el tipo más básico en Python. <br>
					Así que técnicamente, todas las demás clases, ya sean integradas o definidas por el usuario, son clases <br>
					derivadas y todos los objetos son instancias de la clase <strong>object</strong>.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Evaluar distintos tipos de datos para verificar que son instancias de la clase <br>
							object. <br><br>
							<strong style="color: blue;">print</strong>( <strong style="color: blue;">issubclass</strong>(<strong style="color: blue;">list</strong>,<strong style="color: blue;">object</strong>)) <br>
							<strong style="color: blue;">print</strong>( <strong style="color: blue;">isinstance</strong>(<strong style="color: red;">5.5</strong>,<strong style="color: blue;">object</strong> )) <br>
							<strong style="color: blue;">print</strong>( <strong style="color: blue;">isinstance</strong>(<strong style="color: green;">"Hola"</strong>,<strong style="color: blue;">object</strong> ))
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							True <br>
							True <br>
							True
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el escenario de herencia múltiple, cualquier atributo especificado se busca primero en la clase actual. <br>
					Si no se encuentra, la búsqueda continúa en la clases primarias en profundidad, de izquierda a derecha, sin <br>
					buscar la misma clase dos veces. <br>
					Por lo tanto, en el ejemplo anterior de la clase <strong>Cuadrilatero</strong> el orden de búsqueda es <br>
					<strong>[Cuadrilatero, Poligono, Figura, object]</strong>. Este orden también se denomina linealización de la clase <br>
					<strong>Cuadrilatero</strong> y el conjunto de reglas que se utiliza para encontrar este orden se denomina: <br>
					Orden de resolución de métodos, MRO por sus siglas en inglés (Method Resolution Orden). <br>
					El MRO de una clase puede verse como el atributo <strong>__mro__</strong> o el método <strong>mro()</strong>. <br>
					El primero devuelve una tupla mientras que el segundo devuelve una lista.
				</p>
				<br>
			</center>
			<ul>
				<ul>
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								Definir diferentes clases con sus métodos y atributos, luego implementar herencia multinivel entre ellas. <br> 
								Luego imprimir el Orden de Resolución de métodos. <br><br>
								<strong style="color: red;">class</strong> Figura: 
								<br><br>
								<ul>
									<strong style="color: red;">def __init__</strong>(self, area):
									<ul>
										<strong style="color: orange;">self</strong>.area = area
									</ul>
									<br>
									<strong style="color: red;">def</strong> retornar_area(self):
									<ul>
										<strong style="color: blue;">print</strong>(<strong style="color: green;">"El área de la figura es: "</strong>, <strong style="color: orange;">self</strong>.area)
									</ul>
								</ul>
								<br>
								<strong style="color: red;">class</strong> Poligono(Figura):
								<br><br>
								<ul>
									<strong style="color: red;">def __init__</strong>(self, lados, area):
									<ul>
										<strong>Figura.</strong><strong style="color: red;">__init__</strong>(self, area) <br>
										<strong style="color: orange;">self</strong>.lados = lados
									</ul>
									<br>
									<strong style="color: red;">def</strong> retornar_lados(self):
									<ul>
										<strong style="color: blue;">print</strong>(<strong style="color: green;">"Los lados del poligono son: "</strong>, <strong style="color: orange;">self</strong>.lados)
									</ul>
								</ul>
								<br>
								<strong style="color: red;">class</strong> Cuadrilatero(Poligono):
								<ul>
									<strong style="color: red;">def __init__</strong>(self, area):
									<ul>
										<strong>Poligono.</strong><strong style="color: red;">__init__</strong>(self, <strong style="color: red;">4</strong>, area)
									</ul>
								</ul>
								<br><br>
								<strong style="color: blue;">print</strong>(<strong>Cuadrilatero.</strong><strong style="color: red;">__mro__</strong>) <br>
								<strong style="color: blue;">print</strong>(<strong>Cuadrilatero.</strong>mro())
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								(class '__main__.Cuadrilatero'>, class '__main__.Poligono'>, class <br>
									'__main__.Figura'>, class 'object'>) <br>
									[class '__main__.Cuadrilatero'>, class '__main__.Poligono'>, class <br>
									'__main__.Figura'>, class 'object'>]
							</td>
						</tr>
					</table>
					<br><br>
					<p>
						Aquí hay un ejemplo de herencia múltiple un poco más complejo y su visualización junto con el MRO.
					</p>
					<br>
					<center>
						<table>
							<tr>
								<th>Código</th>
							</tr>
							<tr>
								<td>
									Definir diferentes clases con sus métodos y atributos, luego implementar herencia multinivel entre ellas. <br>
									Luego imprimir el orden de resolución de métodos. <br><br>
									<strong style="color: red;">class</strong> X:
									<br><br>
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> Y:
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> Z:
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> A(X, Y):
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> B(Y, Z):
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<strong style="color: red;">class</strong> M(B, A, Z):
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br><br>
									<strong style="color: blue;">print</strong>(<strong>M.</strong>mro())
								</td>
							</tr>
							<tr>
								<th>Resultado</th>
							</tr>
							<tr>
								<td>
									[class '__main__.M'>, class '__main__.B'>, class '__main__.A'>, class <br>
										'__main__.X'>, class '__main__.Y'>, class '__main__.Z'>, class <br>
										'object'>]
								</td>
							</tr>
						</table>
					</center>
				</ul>
			</ul>
			<br><br>
			<hr>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Abstracción</h2>
				<p>
					<strong>La técnica de la abstracción consiste en asilar un determinado elemento sobre su contexto o el resto de elementos <br>
					que lo acompañan y que posiblemente no sean válidos para nuestro propósito.</strong> Gracias a la abstracción separamos las <br>
					características esenciales de un objeto de las no esenciales y tomaremos las caracteristícas y propiedades a tener en cuenta <br>
					de un objeto en el mundo real con el fin de utilizarlas en el sistema que tratamos de implementar. <br>
					En POO solo necesita saber cómo interaccionar con los objetos, no necesita conocer los detalles de cómo está implementada la clase <br>
					a partir de la cual se instancia el objeto. Sólo necesita conocer su interfaz pública. <br>
					El nivel de abstracción puede ser bajo (en un objeto se manipulan datos y métodos individualmente), o alto (en un objeto solo se usan <br> 
					sus métodos de servicio).
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Encapsulación</h2>
				<p>
					La encapsulación es una forma de abstracción, además es un mecanismo para llevar a la práctica la abstracción. <br>
					Cuando una clase existe (se define), se crean objetos a partir de ella, y se usan dichos objetos llamando los métodos <br>
					necesarios. Es decir, crea objetos para usar los servicios que nos proporciona la clase a través de sus métodos. <br>
					<strong>No necesita saber cómo trabaja el objeto, ni saber variables que usa, ni el código que contiene.</strong><br><br>
					Este principio otorga beneficios importantes para el desarrollo de software:
					<ul>
						<li>
							<strong>Modularidad:</strong> El código fuente para un objeto puede ser escrito y mantenido <br>
							independientemente del código fuente para otros objetos. Además, un objeto puede ser fácilmente <br>
							pasado de un lugar a otro del sistema. Por ejemplo, en el caso de la bicicleta de lecturas anteriores, <br>
							es posible darle tu bicicleta a alguien más, y continuará trabajando.
						</li>
						<li>
							<strong>Ocultamiento de información:</strong>
						</li>
					</ul> 
				</p>
			</center>
		</article>
	</section>
</body>
</html>