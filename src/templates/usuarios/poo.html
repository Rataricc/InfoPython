{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Programacion Orientada a Objetos (POO)</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="../../static/css/poo.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<style>
		table, th, td {
			border: 1px solid black;
		}
		footer {
			background-color: #364552;
			padding: 3rem;
			color: #efefef;
		}
		footer section {
			float: right;
		}
		footer p {
			margin: 0;
		}
		footer a {
			transition: color 0.3s ease;
			color: #efefef;
			text-decoration: none;
		}
		footer a:hover {
			color: cornflowerblue;
		}
	</style>
</head>
<body>
	<header>
		<h1>Programacion Orientada a Objetos (POO)</h1>
	</header>
	<section>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Paradigma de Programación Orientada a Objetos</h2>
				<p>
					Un <strong>paradigma</strong> es el resultado de un proceso social en el cual un grupo <br>
					de personas desarrolla nuevas ideas y crea principios y prácticas alrededor de estas ideas.
				</p>
				<img src="{% static 'img/parablog103.jpg'%}" alt="Info-Python-blog" height="450px"><br>
				<p>
					En programación, se trata de un enfoque concreto de desarrollar y estructurar el desarrollo <br>
					de programas en base a Objetos.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Clase</h3>
				<p>
					Una <strong>clase es un modelo que define las propiedades y comportamiento de un tipo de objeto <br>
					concreto</strong>, en la instanciación se hace la lectura de estas definiciones y se crea un objeto a partir <br>
					de ellas. Las clases son abstracciones que representan a un conjunto de objetos con un comportamiento e interfaz <br>
					común. <br><br>
					Una clase se compone de dos partes:
					<ul>
						<li><strong>Atributos>:</strong> esto es, los datos que se refieren al estado del objeto.</li>
						<li><strong>Métodos:</strong> son funciones que pueden aplicarse a objetos.</li>
					</ul>
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Objeto</h3>
				<p>
					<strong>Entidad provista de un conjunto de propiedades o atributos (datos) y de comportamiento o <br>
					funcionalidad (métodos),</strong> los mismos que consecuentemente reaccionan a eventos. Se corresponden <br>
					con los objetos reales del mundo que nos rodea, o con objetos internos del sistema (del programa). <br>
					En realidad, un objeto es una instancia de una clase, por lo que se pueden intercambiar los términos objeto o <br>
					instancia. Un ejemplo de objeto podría ser un automóvil, en el que tendríamos atributos como la marca, el <br>
					número de puertas o el color y métodos como arrancar y parar. O bien cualquier otra combinación de atributos y <br>
					métodos según lo que fuera relevante para nuestro programa. <br><br>
					Un objeto consta de:
					<ul>
						<li>
							<strong>Tiempo de vida:</strong> La duración de un objeto en un programa siempre está limitada en el <br>
							tiempo. La mayoría de los objetos son creados mediante un mecanismo denominado instanciación, <br>
							y cuando dejan de existir se dice que son destruidos.
						</li>
						<li>
							<strong>Estado:</strong> Todo objeto posee un estado, definido por sus atributos. Con él se definen las <br>
							propiedades del objeto, y el estado en que se encuentra en un momento determinado de su exitencia.
						</li>
						<li>
							<strong>Comportamiento:</strong> Todo objeto ha de presentar una interfaz, definida por sus métodos, <br>
							para que el resto de objetos que componen los programas puedan interactuar con él.
						</li>
						<li>
							<strong>Identidad:</strong> Propiedad del objeto que lo distingue de los demás. 
						</li>
					</ul>
				</p>
				<p>
					<strong>
						El equivalente de un objeto en el paradigma estructurado sería una variable. Así mismo la <br>
						instanciación de objetos equivaldría a la declaración de variables, y el tiempo de vida de un <br>
						objeto al ámbito* de una variable.
					</strong><br><br>
					*La zona del programa en la que una variable puede ser utilizada es lo que se conoce como su ámbito de <br>
					una variable local está limitado al código de la función en la que está definida.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<img src="{% static 'img/parablog104.jpg'%}" alt="Info-Python-blog" height="450px"><br><br>
				<p>
					Para modelar soluciones usuando Paradigma orientado a Objetos, comúnmente se utilizan los <br>
					<strong>Diagramas de Clases</strong>, es uno de los diagramas includios en UML 2.5 clasificado dentro de los <br>
					diagramas de estructura y, como tal, se utiliza para representar los elementos que componen un <br>
					sistema de información desde un punto de vista estático. 
				</p>
				<br>
				<img src="{% static 'img/parablog105.jpg'%}" alt="Info-Python-blog" height="450px">
				<br><br>
				<p>
					En Python las clases se definen mediante la palabra clave <strong>class</strong> seguida del nombre de la clase, <br>
					dos puntos (:) y a continuación, indentado, el cuerpo de la clase.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Persona con sus métodos y atributos. <br><br>
							<strong style="color: orange;">class</strong> Persona:
							<ul>
								<strong style="color: orange;">def __init__</strong> (self, nombre, edad, genero, estatura, peso):
								<ul>
									<strong style="color: yellow;">self</strong>.nombre = nombre <br>
									<strong style="color: yellow;">self</strong>.edad = edad <br>
									<strong style="color: yellow;">self</strong>.genero = genero <br>
									<strong style="color: yellow;">self</strong>.estatura = estatura <br>
									<strong style="color: yellow;">self</strong>.peso = peso
								</ul>
								<strong style="color: orange;">def</strong> hablar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Hola soy {}"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> correr(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta corriendo"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> caminar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta caminando"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					El método <strong>__init__</strong>, con una doble barra baja al principio y al final del nombre, se ejecuta justo <br>
					después de crear un nuevo objeto a partir de la clase, proceso que se conoce con el nombre de instanciación. El método <br>
					<strong>__init__</strong> sirve, como sugiere su nombre, para realizar cualquier proceso de inicialización que sea necesario <br>
					como puede ser la asiganación de valores a atributos, cálculos, llamadas a otras funciones o procedimientos.
				</p>
				<p>
					Como vemos el primer parámetro de <strong>__init__</strong> y del resto de métodos de la clase es siempre <strong>self</strong><br>
					que sirve para referirse al objeto actual. <br>
					Este mecanismo es necesario para poder acceder a los atributos y métodos del objeto diferenciando, <br>
					por ejemplo, una variable local <strong>mi_var</strong> de un atributo del objeto <strong>self.mi_var.</strong>
				</p>
				<p>
					Si volvemos al método <strong>__init__</strong> de nuestra clase Persona véremos como se utiliza <strong>self</strong> para <br>
					asignar al atributo nombre del objeto (<strong>self.nombre</strong>) el valor que el programador especifica para <br>
					el párametro nombre. El parámetro nombre se destruye al final de la función, mientras que el atributo nombre se conserva <br>
					(y puede ser accedido) mientras el objeto viva.
				</p>
				<p>
					Para crear un objeto se escribiría el nombre de la clase seguido de cualquier parámetro que sea necesario <br>
					entre paréntesis. Estos parámetros son los que se pasarán al método <strong>__init__</strong>, que como <br>
					decíamos es el método que se llama al instanciar la clase.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Persona con sus métodos y atributos y crear objetos a partir de ella. <br><br>
							<strong style="color: orange;">class</strong> Persona:
							<ul>
								<strong style="color: orange;">def __init__</strong>(self, nombre, edad, sexo, estatura, peso):
								<ul>
									<strong style="color: yellow;">self</strong>.nombre = nombre <br>
									<strong style="color: yellow;">self</strong>.edad = edad <br>
									<strong style="color: yellow;">self</strong>.sexo = sexo <br>
									<strong style="color: yellow;">self</strong>.estatura = estatura <br>
									<strong style="color: yellow;">self</strong>.peso = peso
								</ul>
								<strong style="color: orange;">def</strong> hablar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Hola soy {}"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> correr(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta corriendo"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> caminar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta caminando"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
							</ul>
							<br>
							persona1 = <strong>Persona(<strong style="color: green;">"Juan"</strong>, <strong style="color: red;">23</strong>, <strong style="color: green;">"Masculino"</strong>, <strong style="color: red
							;">170</strong>, <strong style="color: red;">90</strong>)</strong><br>
							persona2 = <strong>Persona(<strong style="color: green;">"Maria"</strong>, <strong style="color: red;">25</strong>, <strong style="color: green;">"Femenino"</strong>, <strong style="color: red
							;">160</strong>, <strong style="color: red;">70</strong>)</strong>
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el ejemplo podemos ver que aunque la definición de la función indica claramente que <br>
					precisa de seis parámetros (self, nombre, edad, sexo, estatura y peso), a la hora de crear un objeto <br>
					de esta clase pasaremos solo cinco parámetros. Esto es así por que Python pasa el primer argumento <br>
					(la referencia al objeto que se crea) automáticamente. <br><br>
					Ahora que ya hemos creado nuestros objetos, podemos acceder a sus atributos y métodos <br>
					mediante la sintaxis <strong>objeto.atributo</strong> y <strong>objeto.método():</strong>
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Persona con sus métodos y atributos y crear un objeto y acceder a sus métodos y atributos. <br><br>
							<strong style="color: orange;">class</strong> Persona:
							<ul>
								<strong style="color: orange;">def __init__</strong>(self, nombre, edad, sexo, estatura, peso):
								<ul>
									<strong style="color: yellow;">self</strong>.nombre = nombre <br>
									<strong style="color: yellow;">self</strong>.edad = edad <br>
									<strong style="color: yellow;">self</strong>.sexo = sexo <br>
									<strong style="color: yellow;">self</strong>.estatura = estatura <br>
									<strong style="color: yellow;">self</strong>.peso = peso
								</ul>
								<strong style="color: orange;">def</strong> hablar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Hola soy {}"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> correr(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta corriendo"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
								<strong style="color: orange;">def</strong> caminar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"{} esta caminando"</strong>. format(<strong style="color: yellow;">self</strong>.nombre))
								</ul>
							</ul>
							<br>
							persona1 = <strong>Persona(<strong style="color: green;">"Juan"</strong>, <strong style="color: red;">23</strong>, <strong style="color: green;">"Masculino"</strong>, <strong style="color: red
							;">170</strong>, <strong style="color: red;">90</strong>)</strong><br>
							persona2 = <strong>Persona(<strong style="color: green;">"Maria"</strong>, <strong style="color: red;">25</strong>, <strong style="color: green;">"Femenino"</strong>, <strong style="color: red
							;">160</strong>, <strong style="color: red;">70</strong>)</strong><br><br>
							<strong style="color: blue;">print</strong>(persona1.nombre) <br>
							<strong style="color: blue;">print</strong>(persona1.edad) <br>
							<strong style="color: blue;">print</strong>(persona1.sexo) <br>
							<strong style="color: blue;">print</strong>(persona1.estatura) <br>
							<strong style="color: blue;">print</strong>(persona1.peso) <br>
							persona1.<strong>hablar()</strong><br>
							persona1.<strong>correr()</strong><br>
							persona1.<strong>caminar()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Juan <br>
							23 <br>
							Masculino <br>
							170 <br>
							90 <br>
							Hola soy Juan <br>
							Juan está corriendo <br>
							Juan está caminando
						</td>
					</tr>
				</table>
				<br>
				<p>
					<strong>Clase:</strong> Persona <br>
					<strong>El objeto instanciado</strong> (creado a partir de esa clase): persona1
				</p>
				<table>
					<tr>
						<th>Atributos:</th>
						<th>Métodos:</th>
					</tr>
					<tr>
						<td>
							<ul>
								<li>nombre: "juan"</li>
								<li>edad: 23</li>
								<li>sexo:"Masculino"</li>
								<li>estatura: 170</li>
								<li>peso: 90</li>
							</ul>
						</td>
						<td>
							<ul>
								<li>hablar()</li>
								<li>correr()</li>
								<li>caminar()</li>
							</ul>
						</td>
					</tr>
				</table>
			</center>
		</article>
		<br><br>
		<hr>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia</h2>
				<p>
					Hay tres conceptos que son básicos para cualquier lenguaje de programación orientada a objetos: <br>
					el <strong>encapsulamiento</strong>, la <strong>herencia</strong> y el <strong>polimorfismo</strong>.
				</p>
				<img src="{% static 'img/parablog106.jpg'%}" alt="Info-Python-blog" height="450px">
				<br>
				<p>
					En un lenguaje orientado a objetos cuando hacemos que una clase (subclase) <strong>herede</strong> de <br>
					otra clase (superclase) estamos haciendo que la subclase contenga todos los atributos y métodos que <br>
					tenía la superclase. <br>
					Al acto de heredar de una clase también se le llama a menudo "extender una clase".
				</p>
			</center>
		</article>
		<br>
		<hr>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia Simple</h2>
				<p>
					Supongamos que queremos modelar los instrumentos musicales de una banda, tendremos entonces una <br>
					<strong>clase Guitarra, una clase Batería, una clase Bajo</strong>, etc. Cada una de estas clases <br>
					tendrá una serie de atributos y métodos, pero ocurre que, por el hecho de ser instrumentos musicales, <br>
					estas clases compartirán muchos de sus atributos y métodos; un ejemplo sería el método <strong>tocar().</strong><br>
					Es más sencillo crear un tipo de objeto Instrumento con sus atributos y métodos comunes e indicar al programa que <br>
					Guitarra, Batería y Bajo son tipos de instrumentos, haciendo que hereden de Instrumento.
				</p>
			</center>
			<ul>
				<ul>
					<img src="{% static 'img/parablog107.jpg'%}" alt="Info-Python-blog" height="450px">
				</ul>
				<p>
					Para indicar que una clase hereda de otra se coloca el nombre de la clase que se hereda entre paréntesis después <br>
					del nombre de la clase:
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Instrumento con sus métodos y atributos y crear clases que hereden <br>
							de ella. <br><br>
							<strong style="color: red;">class</strong> Instrumento: 
							<ul>
								<strong style="color: red;">def __init__</strong>(self, precio):
								<ul>
									<strong style="color: orange;">self</strong>.precio = precio
								</ul>
								<strong style="color: red;">def</strong> tocar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Estamos tocando música"</strong>)
								</ul>
								<strong style="color: red;">def</strong> precio(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El precio de este instrumento es: $"</strong>, <strong style="color: orange;">self</strong>.precio)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Bateria(Instrumento):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<strong style="color: red;">class</strong> Guitarra(Instrumento):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					Como Bateria y Guitarra heredan de Instrumento, ambos tienen un método <strong>tocar()</strong> y un método <br>
					<strong>precio()</strong>, y se inicializan pasando un único parámetro, precio. Pero, ¿qué ocurriría si quisiéramos <br>
					especificar un nuevo parámetro <strong>tipo_cuerda</strong> a la hora de crear un objeto Guitarra?; bastaría con escribir <br>
					un nuevo método <strong>__init__</strong> para la clase Guitarra que se ejecutaría en lugar del <strong>__init__</strong> <br>
					de Instrumento. Esto es lo que se conoce como sobreescribir métodos.
				</p>
				<p>
					Ahora bien, puede ocurrir en algunos casos que necesitemos sobreescribir un método de la clase padre, pero que en ese <br>
					método queramos ejecutar el método de la clase padre porque nuestro nuevo método no necesite más que agregar un par de <br>
					instrucciones extra. En ese caso usamos la sintaxis <strong>SuperClase.metodo(self, args)</strong> para llamar al método <br>
					de igual nombre de la clase padre. Por ejemplo, para llamar al método <strong>__init__</strong> de Instrumento desde Guitarra <br>
					usaríamos <strong>Instrumento.__init__(self, precio).</strong>
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir la clase Instrumento con sus métodos y atributos y crear clases que <br>
							hereden de ella. <br><br>
							<strong style="color: red;">class</strong> Instrumento: 
							<ul>
								<strong style="color: red;">def __init__</strong>(self, precio):
								<ul>
									<strong style="color: orange;">self</strong>.precio = precio
								</ul>
								<strong style="color: red;">def</strong> tocar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Estamos tocando música"</strong>)
								</ul>
								<strong style="color: red;">def</strong> precio(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El precio de este instrumento es: $"</strong>, <strong style="color: orange;">self</strong>.precio)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Bateria(Instrumento):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<strong style="color: red;">class</strong> Guitarra(Instrumento):
							<ul>
								<strong style="color: red;">def __init__</strong>(self, tipo_cuerda, precio):
								<ul>
									<strong>Instrumento.</strong><strong style="color: red;">__init__</strong>(self, precio) <br>
									<strong style="color: orange;">self</strong>.tipo_cuerda = tipo_cuerda
								</ul>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					Observe que en este caso si es necesario especificar el parámetro <strong>self.</strong>
				</p>
			</ul>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia múltiple</h2>
				<p>
					En Python, a diferencia de otros lenguajes como Java o C#, se permite la herencia múltiple, es decir, una clase <br>
					puede heredar de varias clases a la vez. Por ejemplo, podríamos tener una clase Cocodrilo que heredara de la clase <br>
					Terrestre, con métodos como <strong>caminar()</strong> y atributos como <strong>velocidad_caminar</strong> y de la clase <br>
					Acuático, con métodos como <strong>nadar()</strong> y atributos como <strong>velocidad_nadar.</strong> Para indicar que una <br>
					clase hereda de múltiples clases basta con enumerar las clases de las que se hereda separándolas por comas:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el caso de que alguna de las clases padre tuvieran métodos con el mismo nombre y número de parámetros las clases <br>
					sobreescribirían la implementación de los métodos de las clases más a su derecha en la definición. <br>
					En el siguiente ejemplo, como Terrestre se encuentra más a la izquierda, sería la definición de <strong>desplazar()</strong> <br>
					de esta clase la que prevalecerá, y por lo tanto si llamamos al método desplazar de un objeto de tipo Cocodrilo lo que <br>
					se imprimiría sería "El animal anda".
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: red;">pass</strong>
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<br>
							c = <strong>Cocodrilo()</strong> <br>
							c<strong>.desplazar()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							El animal anda
						</td>
					</tr>
				</table>
				<br>
				<p>
					Lo mismo ocurre para el caso de constructor, en caso de que se requiera el uso de el constructor <br>
					de alguna clase específica puede usarse la sintaxis anteriormente vista, <strong>SuperClase.metodo(self, args).</strong>
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Terrestre"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Acuático"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">pass</strong>
							</ul>
							<br>
							c = <strong>Cocodrilo()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Este es el constructor de la clase Terrestre
						</td>
					</tr>
				</table>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							múltiple en una de ellas. <br><br>
							<strong style="color: red;">class</strong> Terrestre:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Terrestre"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal anda"</strong>)
								</ul>
							</ul>
							<strong style="color: red">class</strong> Acuatico:
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Este es el constructor de la clase Acuático"</strong>)
								</ul>
								<strong style="color: red;">def</strong> desplazar(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El animal nada"</strong>)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cocodrilo(Terrestre, Acuatico):
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong>Acuatico.</strong><strong style="color: red;">__init__</strong>(self)
								</ul>
							</ul>
							<br>
							c = <strong>Cocodrilo()</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Este es el cosntructor de la clase Acuático
						</td>
					</tr>
				</table>
				<br><br>
				<p>
					En el segundo ejemplo se define cual de los constructores de las superclases se va a utilizar, permitiéndonos especificar <br>
					qué métodos usará de cada una de las clases padre sin importar quien esté más a su derecha en la definición de la clase.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Herencia multinivel en Python</h2>
				<p>
					Por otro lado, también podemos heredar de una clase derivada. Esto se llama herencia multinivel y puede ser de cualquier <br>
					profundidad en Python. <br>
					En la herencia multinivel, las características de la clase base y la clase derivada se heredan en la nueva clase derivada.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir diferentes clases con sus métodos y atributos, luego implementar herencia <br>
							multinivel entre ellas. <br><br>
							<strong style="color: red;">class</strong> Figura: 
							<ul>
								<strong style="color: red;">def __init__</strong>(self, area):
								<ul>
									<strong style="color: orange;">self</strong>.area = area
								</ul>
								<strong style="color: red;">def</strong> retornar_area(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"El área de la figura es: "</strong>, <strong style="color: orange;">self</strong>.area)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Poligono(Figura):
							<ul>
								<strong style="color: red;">def __init__</strong>(self, lados, area):
								<ul>
									<strong>Figura.</strong><strong style="color: red;">__init__</strong>(self, area) <br>
									<strong style="color: orange;">self</strong>.lados = lados
								</ul>
								<strong style="color: red;">def</strong> retornar_lados(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Los lados del poligono son: "</strong>, <strong style="color: orange;">self</strong>.lados)
								</ul>
							</ul>
							<strong style="color: red;">class</strong> Cuadrilatero(Poligono):
							<ul>
								<strong style="color: red;">def __init__</strong>(self, area):
								<ul>
									<strong>Poligono.</strong><strong style="color: red;">__init__</strong>(self, <strong style="color: red;">4</strong>, area)
								</ul>
							</ul>
						</td>
					</tr>
				</table>
				<br>
				<p>
					Aquí por ejemplo, <strong>Poligono</strong> se deriva de <strong>Figura</strong>, y <strong>Cuadrilatero</strong> se deriva de <br>
					<strong>Poligono</strong> por lo que <strong>Cuadrilatero</strong> tendra los métodos y atributos tanto de las clase <strong>Poligono</strong><br>
					como de la clase <strong>Figura</strong>. Si en la clase <strong>Poligono</strong> alguno de los métodos de <strong>Figura</strong> es redefinido <br>
					<strong>Cuadrilatero</strong> heredara del método redfinido.
				</p>
				<br><br>
				<p>
					<strong>
						Nota: En el diseño de jerarquías de herencia no siempre es del todo fácil decidir cuándo una clase <br>
						debe extender a otra. La regla práctica para decidir si una clase (S) puede ser definida como heredera <br>
						de otra (T) es que debe cumplirse que "S es un T". Por ejemplo, Perro es una Animal, pero Vehiculo no es un Motor.
					</strong>
				</p>
			</center>
		</article>
		<br><br>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Método de resolución de orden en Python</h2>
				<p>
					Cada clase en Python se deriva de la clase <strong>object</strong>. Es el tipo más básico en Python. <br>
					Así que técnicamente, todas las demás clases, ya sean integradas o definidas por el usuario, son clases <br>
					derivadas y todos los objetos son instancias de la clase <strong>object</strong>.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Evaluar distintos tipos de datos para verificar que son instancias de la clase <br>
							object. <br><br>
							<strong style="color: blue;">print</strong>( <strong style="color: blue;">issubclass</strong>(<strong style="color: blue;">list</strong>,<strong style="color: blue;">object</strong>)) <br>
							<strong style="color: blue;">print</strong>( <strong style="color: blue;">isinstance</strong>(<strong style="color: red;">5.5</strong>,<strong style="color: blue;">object</strong> )) <br>
							<strong style="color: blue;">print</strong>( <strong style="color: blue;">isinstance</strong>(<strong style="color: green;">"Hola"</strong>,<strong style="color: blue;">object</strong> ))
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							True <br>
							True <br>
							True
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el escenario de herencia múltiple, cualquier atributo especificado se busca primero en la clase actual. <br>
					Si no se encuentra, la búsqueda continúa en la clases primarias en profundidad, de izquierda a derecha, sin <br>
					buscar la misma clase dos veces. <br>
					Por lo tanto, en el ejemplo anterior de la clase <strong>Cuadrilatero</strong> el orden de búsqueda es <br>
					<strong>[Cuadrilatero, Poligono, Figura, object]</strong>. Este orden también se denomina linealización de la clase <br>
					<strong>Cuadrilatero</strong> y el conjunto de reglas que se utiliza para encontrar este orden se denomina: <br>
					Orden de resolución de métodos, MRO por sus siglas en inglés (Method Resolution Orden). <br>
					El MRO de una clase puede verse como el atributo <strong>__mro__</strong> o el método <strong>mro()</strong>. <br>
					El primero devuelve una tupla mientras que el segundo devuelve una lista.
				</p>
				<br>
			</center>
			<ul>
				<ul>
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								Definir diferentes clases con sus métodos y atributos, luego implementar herencia multinivel entre ellas. <br> 
								Luego imprimir el Orden de Resolución de métodos. <br><br>
								<strong style="color: red;">class</strong> Figura: 
								<br><br>
								<ul>
									<strong style="color: red;">def __init__</strong>(self, area):
									<ul>
										<strong style="color: orange;">self</strong>.area = area
									</ul>
									<br>
									<strong style="color: red;">def</strong> retornar_area(self):
									<ul>
										<strong style="color: blue;">print</strong>(<strong style="color: green;">"El área de la figura es: "</strong>, <strong style="color: orange;">self</strong>.area)
									</ul>
								</ul>
								<br>
								<strong style="color: red;">class</strong> Poligono(Figura):
								<br><br>
								<ul>
									<strong style="color: red;">def __init__</strong>(self, lados, area):
									<ul>
										<strong>Figura.</strong><strong style="color: red;">__init__</strong>(self, area) <br>
										<strong style="color: orange;">self</strong>.lados = lados
									</ul>
									<br>
									<strong style="color: red;">def</strong> retornar_lados(self):
									<ul>
										<strong style="color: blue;">print</strong>(<strong style="color: green;">"Los lados del poligono son: "</strong>, <strong style="color: orange;">self</strong>.lados)
									</ul>
								</ul>
								<br>
								<strong style="color: red;">class</strong> Cuadrilatero(Poligono):
								<ul>
									<strong style="color: red;">def __init__</strong>(self, area):
									<ul>
										<strong>Poligono.</strong><strong style="color: red;">__init__</strong>(self, <strong style="color: red;">4</strong>, area)
									</ul>
								</ul>
								<br><br>
								<strong style="color: blue;">print</strong>(<strong>Cuadrilatero.</strong><strong style="color: red;">__mro__</strong>) <br>
								<strong style="color: blue;">print</strong>(<strong>Cuadrilatero.</strong>mro())
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								(class '__main__.Cuadrilatero'>, class '__main__.Poligono'>, class <br>
									'__main__.Figura'>, class 'object'>) <br>
									[class '__main__.Cuadrilatero'>, class '__main__.Poligono'>, class <br>
									'__main__.Figura'>, class 'object'>]
							</td>
						</tr>
					</table>
					<br><br>
					<p>
						Aquí hay un ejemplo de herencia múltiple un poco más complejo y su visualización junto con el MRO.
					</p>
					<br>
					<center>
						<table>
							<tr>
								<th>Código</th>
							</tr>
							<tr>
								<td>
									Definir diferentes clases con sus métodos y atributos, luego implementar herencia multinivel entre ellas. <br>
									Luego imprimir el orden de resolución de métodos. <br><br>
									<strong style="color: red;">class</strong> X:
									<br><br>
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> Y:
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> Z:
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> A(X, Y):
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br>
									<strong style="color: red;">class</strong> B(Y, Z):
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<strong style="color: red;">class</strong> M(B, A, Z):
									<ul>
										<strong style="color: red;">pass</strong>
									</ul>
									<br><br>
									<strong style="color: blue;">print</strong>(<strong>M.</strong>mro())
								</td>
							</tr>
							<tr>
								<th>Resultado</th>
							</tr>
							<tr>
								<td>
									[class '__main__.M'>, class '__main__.B'>, class '__main__.A'>, class <br>
										'__main__.X'>, class '__main__.Y'>, class '__main__.Z'>, class <br>
										'object'>]
								</td>
							</tr>
						</table>
					</center>
				</ul>
			</ul>
			<br><br>
			<hr>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Abstracción</h2>
				<p>
					<strong>La técnica de la abstracción consiste en asilar un determinado elemento sobre su contexto o el resto de elementos <br>
					que lo acompañan y que posiblemente no sean válidos para nuestro propósito.</strong> Gracias a la abstracción separamos las <br>
					características esenciales de un objeto de las no esenciales y tomaremos las caracteristícas y propiedades a tener en cuenta <br>
					de un objeto en el mundo real con el fin de utilizarlas en el sistema que tratamos de implementar. <br>
					En POO solo necesita saber cómo interaccionar con los objetos, no necesita conocer los detalles de cómo está implementada la clase <br>
					a partir de la cual se instancia el objeto. Sólo necesita conocer su interfaz pública. <br>
					El nivel de abstracción puede ser bajo (en un objeto se manipulan datos y métodos individualmente), o alto (en un objeto solo se usan <br> 
					sus métodos de servicio).
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Encapsulación</h2>
				<p>
					La encapsulación es una forma de abstracción, además es un mecanismo para llevar a la práctica la abstracción. <br>
					Cuando una clase existe (se define), se crean objetos a partir de ella, y se usan dichos objetos llamando los métodos <br>
					necesarios. Es decir, crea objetos para usar los servicios que nos proporciona la clase a través de sus métodos. <br>
					<strong>No necesita saber cómo trabaja el objeto, ni saber variables que usa, ni el código que contiene.</strong><br><br>
					Este principio otorga beneficios importantes para el desarrollo de software:
					<ul>
						<li>
							<strong>Modularidad:</strong> El código fuente para un objeto puede ser escrito y mantenido <br>
							independientemente del código fuente para otros objetos. Además, un objeto puede ser fácilmente <br>
							pasado de un lugar a otro del sistema. Por ejemplo, en el caso de la bicicleta de lecturas anteriores, <br>
							es posible darle tu bicicleta a alguien más, y continuará trabajando.
						</li>
						<li>
							<strong>Ocultamiento de información:</strong> Un objeto tiene una interfaz pública que otros objetos pueden utilizar <br>
							para comunicarse con él. El objeto puede mantener información y métodos privados que pueden ser modificados a cualquier <br>
							tiempo sin afectar los otros objetos que dependen de él. No es necesario entender cómo usar el mecanismo de los engranajes <br>
							de una bicicleta para poder utilizarlo.
						</li>
					</ul>
					<br>
					<strong>La encapsulación describe el hecho de que los objetos se usan como cajas negras. Así, un objeto encapsula datos y métodos, <br>
					que están dentro del objeto.</strong>
					<ul>
						<li>
							<strong>Interfaz pública de una clase:</strong> Es un conjunto de métodos (métodos de servicio) que sirve para que <br>
							los objetos de una clase proporcionen sus servicios. Estos servicios son los que pueden ser llamados por un cliente.
						</li>
						<li>
							<strong>Método de soporte:</strong> Son métodos adicionales en un objeto que no definen un servicio utilizable <br>
							por un cliente, pero que ayudan a otros métodos en sus tareas.
						</li>
					</ul>
				</p>
				<p>
					La encapsulación es un mecanismo de control que restringe la capacidad de modificar el estado (el conjunto de propiedades, <br> 
					atributos o datos) de un objeto sólo por medio de los métodos del propio objeto, permitiendo que los atributos de un objeto <br>
					puedan ocultarse (superficilamente) para que no sean accedidos desde fuera de la difinición de una clase. Para ello, es necesario <br>
					nombrar los atributos con un prefijo de doble subrayado: <strong>__atributo</strong>.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Encapsulación y niveles de privacidad</h2>
				<p>
					En encapuslamiento nos permite definir niveles de privacidad para señalar qué métodos y atributos no deben utilizarse fuera <br>
					de la clase y así evitar exponer excesivamente los detalles de la implementación de una clase o un objeto.
				</p>
				<p>
					Esto se consigue en otros lenguajes de programación como Java utilizando modificadores de acceso que definen si cualquiera puede <br>
					acceder a esa función o variable(public) o si está restringiendo el acceso a la propia clase (private).
				</p>
				<p>
					En Python no existen los modificadores de acceso, y lo que se suele hacer es usar convenciones a la hora de nombrar métodos y atributos, <br>
					de forma que se señala su carácter privado, para su exlcusión del espacio de nombres, o para indicar una función especial, normalmente <br>
					asociada a funcionamiento estándar del lenguaje.
				</p>
				<ul>
					<li>
						<strong>_nombre:</strong> Los nombres que comienzan con un único guión bajo indican de forma débil un uso interno. <br>
						Además, estos nombres no se incorporan en el espacio de nombres de un módulo al importarlo con "from...import *".
					</li>
					<li>
						<strong>__nombre:</strong>Los nombres que empiezan por dos guiones bajos (y no termina también con dos guiones bajos) <br>
						indican su uso privado en la clase.
					</li>
					<li>
						<strong>__nombre__:</strong>Los nombres que comiezan y acaban con dos guiones bajos indican atributos "mágicos", de uso <br>
						especial y que residen en espacios de nombres que puede manipular el usuario. Solamente deben usarse en la menera que se describe <br>
						en la documentación de Python y debe evitarse la creación de nuevos atributos de este tipo. <br><br>
						Algunos ejemplos  de nombres "singulares" de este tipo son: 
						<ul>
							<li>
								<strong>__init__:</strong> Método de inicialización de objetos
							</li>
							<li>
								<strong>__del__:</strong> Método de destrucción de objetos
							</li>
							<li>
								<strong>__doc__:</strong> Cadena de documentación de módulos, clases...
							</li>
							<li>
								<strong>__class__:</strong> nombre de la clase
							</li>
							<li>
								<strong>__str__:</strong> Método que devuelve una descripción de la clase como cadena de texto
							</li>
							<li>
								<strong>__repr__:</strong> Método que devuelve una representación de la clase como cadena de texto
							</li>
							<li>
								<strong>__module__:</strong> Módulo al que pertence la clase
							</li>
						</ul>
					</li>
				</ul>
				<br><br>
				<p>
					En el siguiente ejemplo sólo se imprimirá la cadena correspondiente al método <strong>publico(),</strong> mientras <br>
					que al intentar llamar al método <strong>__privado()</strong> Python lanzará una excepción debido a que no existe, <br>
					evidentemente existe pero no podemos ver porque es privado.
				</p>
				<br><br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir una clase con métodos públicos y privados. <br><br>
							<strong style="color: red;">class</strong> Ejemplo:
							<ul>
								<strong style="color: red;">def</strong> publico(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Publico"</strong>)
								</ul>
								<strong style="color: red;">def</strong>__privado(self): 
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Privado"</strong>)
								</ul>
							</ul>
							<br>
							ej = <strong>Ejemplo</strong>() <br>
							ej.publico() <br>
							ej.__privado()
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Publico <br>
							Traceback (most recent call last): <br>
							File "input>", line 11, in module> <br>
							AttributeError: 'Ejemplo' object has no attribute '__privado'
						</td>
					</tr>
				</table>
				<br><br>
				<p>
					Este mecanismo se basa en que los nombres que comienzen con un doble guión bajo se renombran para incluir <br>
					el nombre de la clase (característica que se conoce con el nombre de name mangling). Esto implica que el <br>
					método o atributo no es realmente privado, y podemos acceder a él mediante una pequeña trampa:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir una clase con métodos públicos y privados. <br><br>
							<strong style="color: red;">class</strong> Ejemplo:
							<ul>
								<strong style="color: red;">def</strong> publico(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Publico"</strong>)
								</ul>
								<strong style="color: red;">def</strong>__privado(self): 
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Privado"</strong>)
								</ul>
							</ul>
							<br>
							ej = <strong>Ejemplo</strong>() <br><br>
							ej.publico() <br>
							ej.<strong>_Ejemplo</strong>__privado()
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Publico <br>
							Privado
						</td>
					</tr>
				</table>
				<br><br>
				<p>
					En ocasiones también puede suceder que queremos permitir el acceso a algún atributo de nuestro objeto, pero que este <br>
					se produzca de forma controlada. Para esto podemos escribir métodos cuyo único cometido sea este, métodos que normalmente, <br>
					por convención, tienen nombres como getVariable y setVariable; de ahí que se conozcan también con el nombre de getters y setters.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir una clase con sus atributos privados y sus métodos getters y setters. <br><br>
							<strong style="color: red;">class</strong> Fecha():
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: orange;">self</strong>.__dia = <strong style="color: red;">1</strong>
								</ul>
								<br>
								<strong style="color: red;">def</strong> getDia(self):
								<ul>
									<strong style="color: red;">return</strong> <strong style="color: orange;">self</strong>.__dia
								</ul>
								<br>
								<strong style="color: red;">def</strong> setDia(self, dia):
								<ul>
									<strong style="color: red;">if</strong> dia > <strong style="color: red;">0</strong> <strong style="color: #1A91C2;">and</strong> dia < <strong style="color: red;">31</strong>:
									<ul>
										<strong style="color: orange;">self</strong>.__dia = dia
									</ul>
									<strong style="color: red;">else</strong>:
									<ul>
										<strong style="color: blue;">print</strong>(<strong style="color: green;">"Error"</strong>)
									</ul>
								</ul>
							</ul>
							<br><br>
							mi_fecha = <strong>Fecha()</strong><br><br>
							mi_fecha.setDia(<strong style="color: red;">33</strong>) <br><br>
							mi_fecha.__dia= <strong style="color: red;">30</strong><br>
							<strong style="color: blue;">print</strong>(mi_fecha.getDia())
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							Error <br>
							1
						</td>
					</tr>
				</table>
				<br><br>
				<p>
					Esto se podría simplificar mediante propiedades, que abstraen al usuario del hecho de que se está utilizando métodos accesores <br>
					para obtener y modificar los valores del atributo:
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Definir una clase con sus atributos privados y sus métodos getters y setters. <br><br>
							<strong style="color: red;">class</strong> Fecha():
							<ul>
								<strong style="color: red;">def __init__</strong>(self):
								<ul>
									<strong style="color: orange;">self</strong>.__dia = <strong style="color: red;">1</strong>
								</ul>
								<br>
								<strong style="color: red;">def</strong> getDia(self):
								<ul>
									<strong style="color: red;">return</strong> <strong style="color: orange;">self</strong>.__dia
								</ul>
								<br>
								<strong style="color: red;">def</strong> setDia(self, dia):
								<ul>
									<strong style="color: red;">if</strong> dia > <strong style="color: red;">0</strong> <strong style="color: #1A91C2;">and</strong> dia < <strong style="color: red;">31</strong>:
									<ul>
										<strong style="color: orange;">self</strong>.__dia = dia
									</ul>
									<strong style="color: red;">else</strong>:
									<ul>
										<strong style="color: blue;">print</strong>(<strong style="color: green;">"Error"</strong>)
									</ul>
								</ul>
								<br>
								dia = <strong style="color: blue;">property</strong>(getDia, setDia)
							</ul>
							<br><br>
							mi_fecha = <strong>Fecha()</strong><br><br>
							mi_fecha.dia = <strong style="color: red;">30</strong><br><br>
							<strong style="color: blue;">print</strong>(mi_fecha.dia)
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							30
						</td>
					</tr>
				</table>
				<br><br>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Polimorfismo</h2>
				<p>
					En programación orientada a objetos <strong>se denomina polimorfismo a la capacidad que tienen los objetos <br>
					de una clase de responder al mismo mensaje o evento en función de los parámetros utilizados durante su invocación.</strong><br>
					Un objeto polimórfico es una entidad que puede contener valores de diferentes tipos durante la ejecución del programa. <br>
					Esto se puede conseguir a través de la herencia: un objeto de una clase derivada es al mismo tiempo un objeto de la clase <br>
					padre, de forma que allí donde se requiere un objeto de la clase padre también se puede utilizar uno de la clase hija.
				</p>
				<p>
					Python, al ser de tipado dinámico, no impone restricciones a los tipos que se le pueden pasar a una función, por ejemplo, <br>
					más allá de que el objeto se comporte como se espera: si se va a llamar a un método <strong>f()</strong> del objeto pasado <br>
					como parámetro, por ejemplo, evidentemente el objeto tendrá que contar con ese método. <br>
					En ocasiones también se utiliza el término polimorfismo para referirse a la sobrecarga de métodos, término que se define como <br>
					la capacidad del lenguaje de determinar qué método ejecutar de entre varios métodos con igual nombre según el tipo o número de <br>
					los parámetros que se le pasa. En Python no existe sobrecarga de métodos (el último método sobreescribiría la implementación <br> 
					de los anteriores), aunque se puede conseguir un comportamiento similiar recurriendo a funciones con valores por defecto para los <br>
					parámetros o a la sintaxis <strong>*params</strong> o <strong>**params</strong>, o bien usando decoradores. 
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Sobrecarga de Métodos</h2>
				<p>
					La sobrecarga de métodos es también conocida por Overriding Methods, le permite sustituir un método proveniente de la Clase Base, <br>
					en la Clase Derivada debe definir un método con la misma forma (es decir, mismo nombre de método y mismo número de párametros que <br> 
					como está definido en la Clase Base).
				</p>
				<br>
				<table>
					<tr>
						<th>
							Código
						</th>
					</tr>
					<tr>
						<td>
							Definir una clase con sus métodos y atributos implementando sobrecarga de métodos. <br><br>
							<strong style="color: red;">class</strong> Persona():
							<ul>
								<strong style="color: red;">def__init__</strong>(self, cedula): 
								<ul>
									<strong style="color: orange;">self</strong>.cedula = cedula
								</ul>
								<br>
								<strong style="color: red;">def</strong> mensaje(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Mensaje desde la clase Persona"</strong>)
								</ul>
							</ul>
							<br>
							<strong style="color: red;">class</strong> Obrero(Persona):
							<ul>
								<strong style="color: red;">def__init__</strong>(self, cedula):
								<ul>
									<strong>Persona.</strong><strong style="color: red;">__init__</strong>(self, cedula)
									<strong style="color: orange;">self</strong>.__especialista = <strong style="color: red;">1</strong>
								</ul>
								<br>
								<strong style="color: red;">def</strong> mensanje(self):
								<ul>
									<strong style="color: blue;">print</strong>(<strong style="color: green;">"Mensaje desde la clase Obrero"</strong>)
								</ul>
							</ul>
							<br><br>
							obrero_planta = <strong>Obrero</strong>(<strong style="color: red;">12345</strong>) <br>
							obrero_planta.mensaje() <br>
						</td>
					</tr>
					<tr>
						<th>
							Resultado
						</th>
					</tr>
					<tr>
						<td>
							Mensaje desde la clase Obrero
						</td>
					</tr>
				</table>
				<br><br>
			</center>
			<ul>
				<ul>
					<ul>
						<p>
							Lo que se logra definiendo el método <strong>mensaje()</strong> en la Clase Derivada <strong>(Obrero)</strong> se conoce como <br>
							Método Overriding haciendo que cuando se crea el objeto (en este caso  <strong>obrero_planta</strong>) y se llame al método <br>
							<strong>mensaje()</strong> este será tomado de la propia clase y no de la Clase Base <strong>Persona</strong>. <br>
							Si comenta o borra el método <strong>mensaje()</strong> de la clase <strong>Obrero</strong> (Clase Derivada) y corre nuevamente <br>
							el código, el método llamado será el <strong>mensaje()</strong> de la Clase Base <strong>Persona</strong>.
						</p>
					</ul>
				</ul>
			</ul>
		</article>
		<article class="post">
			<center>
				<h2 style="color: #C66250;">Sobrecarga de Operadores</h2>
			</center>
			<ul>
				<ul>
					<ul>
						<ul>
							<p>
								La sobrecarga de operadores es también conocida por Overloading Operators, trata básicamente de lo mismo <br>
								que la sobrecarga de métodos pero pertenece en esencia al ámbito de los operadores aritméticos, binarios, <br>
								de comparación y lógicos.
							</p>
							<ul>
								<table>
									<tr>
										<th>
											Código
										</th>
									</tr>
									<tr>
										<td>
											Definir una clase con sus métodos y atributos implementando sobrecarga de operadores. <br><br>
											<strong style="color: red;">class</strong> Punto:
											<ul>
												<strong style="color: red;">def__init__</strong>(self, x = <strong style="color: red;">0</strong>, y = <strong style="color: red;">0</strong>):
												<ul>
													<strong style="color: orange;">self</strong>.x = x <br>
													<strong style="color: orange;">self</strong>.y = y
												</ul>
												<br>
												<strong style="color: red;">def__add__</strong>(self, other):
												<ul>
													x = <strong style="color: orange;">self</strong>.x + other.x <br>
													y = <strong style="color: orange;">self</strong>.y + other.y <br>
													<strong style="color: red;">return</strong> x, y
												</ul>
											</ul>
											<br><br>
											punto1 = <strong>Punto</strong>(<strong style="color: red;">4</strong>,<strong style="color: red;">6</strong>) <br>
											punto2 = <strong>Punto</strong>(<strong style="color: red;">1</strong>,<strong style="color: red;">-2</strong>) <br><br>
											<strong style="color: blue;">print</strong>(punto1 + punto2)
										</td>
									</tr>
									<tr>
										<th>
											Resultado
										</th>
									</tr>
									<tr>
										<td>
											(5, 4)
										</td>
									</tr>
								</table>
							</ul>
						</ul>
					</ul>
				</ul>
			</ul>
		</article>
	</section>
	<footer>
		<section>
			<a href="#">Ir al comienzo</a>
		</section>
	</footer>
</body>
</html>