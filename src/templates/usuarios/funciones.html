{% load static %}
<!DOCTYPE html>
<html>
<head>
	<title>Funciones</title>
	<link rel="preconnect" href="https://fonts.googleapis.com">
	<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
	<link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
	<link rel="stylesheet" href="../../static/css/funciones.css">
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/4.0.0/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
	<style>
		table, th, td {
			border: 1px solid black;
		}
	</style>
</head>
<body>
	<header>
		<h1>Funciones</h1>
	</header>
	<section>
		<article class="post">
			<center>
				<h2 tyle="color: #C66250;">Introducción</h2>
				<h3 style="color: cornflowerblue;">Funciones</h3>
				<p>
					Una <strong>función</strong> es un fragmento de código con un nombre asociado que <strong>realiza una serie de <br>
					tareas y devuelve un valor.</strong> A los fragmentos de código que tienen un nombre asociado y no devuelven valores <br>
					se les suele llamar <strong>procedimientos</strong>.
				</p>
				<p>
					En Python no existen los procedimientos, ya que <strong>cuando el programador no especifica un valor de <br>
					retorno la función devuelve el valor None (nada)</strong>, equivale al null en Java.
				</p>
				<p>
					El uso de funciones es un componente muy importante del paradigma de la programación <br>
					llamada estructurada, y tienen varias ventajas:
					<ul>
						<li>
							<strong>Modularización:</strong> permite segmentar un programa complejo en una serie de partes o <br>
							módulos más simples, facilitando así la programación y el depurado.
						</li>
						<li>
							<strong>Reutilización:</strong> permite reutilizar un misma función en distintos programas.
						</li>
					</ul>
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Sentencia def</h3>
				<p>
					La sentencia <strong>def</strong> es una definición de función usada para crear funciones definidas por el <br>
					usuario.
				</p>
				<p>
					Una <strong>definición de función</strong> es una sentencia ejecutable. Su ejecución enlaza el nombre de la <br>
					función en el namespace local actual a un objeto función (un envoltorio alrededor del código ejecutable <br>
					para la función). Este objeto función contiene una referencia al namespace local como el namespace global <br>
					para ser usado cuando la función es llamda.
				</p>
				<p>
					<strong>La definición de la función no ejecuta el cuerpo de la misma; esto es ejecutado solamente <br>
					cuando la función  es llamada.</strong>
				</p>
				<p>
					En Python las funciones se declaran de la siguiente forma:
					<table>
						<tr>
							<td>
								def mi_funcion(param1, param2): 
								<ul>
									print(param1, param2)
								</ul>
							</td>
						</tr>
					</table>
				</p>
				<p>
					Es decir, la palabra clave <strong>def</strong> seguida del nombre de la función y entre paréntesis cero o más <br>
					argumentos como entrada separados por comas, en otra línea, indentando y después de los dos puntos tendríamos las <br>
					líneas del código que conforman el conjunto de instrucciones a ser ejecutadas por la función. <br>
					También podemos encontrarnos con una cadena de texto como primera línea del cuerpo de la función, <br>
					estas cadenas se conocen con el nombre de <strong>docstring</strong>(cadena de documentación) y sirven, <br>
					como su nombre indica, a modo de documentación de la función. Hay herramientas que usan las docstrings para producir <br>
					automáticamente documentación en línea o imprimible, o para permitirle al usuario que navegue el código en forma <br>
					interactiva; es una buena práctica incluir docstrings en el código que uno escribe, por lo que se debe hacer un hábito <br>
					de esto. 
					<table>
						<tr>
							<td>
								def mi_funcion(param1, param2):
								<ul>
									''''''Esta función imprime los dos valores pasados como parámetros'''''' <br>
									print(param1) <br>
									print(param2)
								</ul>
							</td>
						</tr>
					</table>
				</p>
				<p>
					Como se mencionó anteriormente en la definición de la función lo único que hacemos es asociar <br>
					un nombre al fragmento de código que conforma l función, de forma que podamos ejecutar dicho código <br>
					más tarde referenciándolo por su nombre. Para llamar a la función (ejecutar su código) se escribiría: <br>
					<ul>
						mi_funcion("Hola", 2)
					</ul>
				</p>
				<p>
					Es decir, el nombre de la función a la que queremos llamar seguido de los valores que queramos pasar <br>
					como parámetro entre paréntesis.
					<table>
						<tr>
							<th>Código</th>
						</tr>
						<tr>
							<td>
								Imprimir los valores pasados como parámetros. <br><br>
								<strong style="color: red;">def</strong> mi_funcion(param1, param2):
								<ul>
									<strong style="color: green;">"""Esta función imprime los dos valores pasados como parámetros"""</strong><br>
									<strong style="color: blue;">print</strong>(param1) <br>
									<strong style="color: blue;">print</strong>(param2)
								</ul>
								mi_funcion(<strong style="color: green;">"Hola"</strong>, <strong style="color: red;">2</strong> )
							</td>
						</tr>
						<tr>
							<th>Resultado</th>
						</tr>
						<tr>
							<td>
								Hola <br>
								2
							</td>
						</tr>
					</table>
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h2>Argumentos y parámetros</h2>
				<p>
					Al definir una función los valores que se reciben se denominan <strong>parámetros</strong>, pero durante la <br>
					llamada los valores que se envían se denominan <strong>argumentos.</strong>
				</p>
				<img src="{% static 'img/parablog43.jpg'%}" height="200px">
				<ul>
					<li>
						<strong style="color: cornflowerblue;">Por posicíon</strong><br>
						Cuando se envían argumentos a una función, estos se reciben por orden en los páremetros definidos. <br>
						La asociación de los parámetros y los valores pasados a la función se hace normalmente de izquierda a <br>
						derecha: como, en el ejemplo anterior, la función sumar recibe el valor de la variable numero_1 y la suma <br>
						con el valor que recibe en segundo lugar, numero_2. <br>
						En este caso se dice que son <strong>argumentos por posición</strong>. 
					</li>
					<br>
					<li>
						<strong style="color: cornflowerblue;">Por nombre</strong><br>
						Sin embargo también es posible modificar el orden de los parámetros si indicamos el nombre <br>
						del parámetro al que asociar el valor a la hora de llamar la función: 
						<ul>
							sumar(numero_2 = 2, numero_1 = 3)
						</ul>
					</li>
					<br>
					<li>
						<strong style="color: cornflowerblue;">Llamada sin argumentos</strong><br>
						El número de valores que se pasan como parámetros al llamar a la función tiene que coincidir <br>
						con el número de parámetros que la función acepta según la declaración de la función. <br>
						Si al momento de llamar una función la cual tiene definidos unos parámetros no pasa los argumentos <br>
						correctamente provocará una excepción <strong>TypeError</strong>. Por ejemplo:
						<table>
							<tr>
								<th>Código</th>
							</tr>
							<tr>
								<td>
									Imprimir los valores pasados como parámetros. <br>
									<strong style="color: red;">def</strong> mi_funcion(param1, param2):
									<ul>
										<strong>"""Esta función imprime los dos valores pasados como parámetros"""</strong><br>
										<strong style="color: blue;">print</strong>(param1) <br>
										<strong style="color: blue;">print</strong>(param2)
									</ul>
									mi_funcion(<strong style="color: green;">"Hola"</strong>)
								</td>
							</tr>
							<tr>
								<th>Resultado</th>
							</tr>
							<tr>
								<td style="color: red;">
									<strong>
										Traceback (most recent call last):
										<ul>
											File "input>", line 5, in <module></module>
										</ul>
										TypeError: mi_funcion() missing 1 required positional argument: 'param2'
									</strong>
								</td>
							</tr>
						</table>
					</li>
					<br>
					<li>
						<strong style="color: cornflowerblue;">Parámetros por defecto</strong><br>
						Para solucionar la excepción <strong>TypeError</strong> ejecutada al momento de la llamada a una función <br>
						sin argumentos, entonces se puede asignar unos <strong>valores por defecto nulos</strong> a los párametros, <br>
						de esa forma puede hacer una comprobación antes de ejecutar el código de la función:
						<table>
							<tr>
								<th>Código</th>
							</tr>
							<tr>
								<td>
									Dado dos números calcular la resta de ambos números. Si al llamar a la función se pasa solo un parámetro <br>
									imprimir un mensaje informando que se requieren dos números para realizar la operación. <br><br>
									<strong style="color: red;">def</strong> resta(num1= <strong style="color: blueviolet;">None</strong>, num2= <strong style="color: blueviolet;">None</strong>):
									<ul>
										<strong style="color: green;">"""Esta función imprime la resta de los dos valores pasados como parámetros"""</strong><br>
										<strong style="color: red;">if</strong> a == <strong style="color: blueviolet;">None </strong><strong style="color: red;">or</strong> b == <strong style="color: blueviolet;">None</strong>:
										<ul>
											<strong style="color: blue;">print</strong>(<strong style="color: green;">"Error, debes enviar dos números a la función"</strong>) <br>
											<strong style="color: red;">return</strong>
										</ul>
										<strong style="color: red;">return</strong> a - b
									</ul>
									resta(<strong style="color: red;">30, 10</strong>) <br><br>
									resta() <br><br>
								</td>
							</tr>
							<tr>
								<th>Resultado</th>
							</tr>
							<tr>
								<td>
									20 <br>
									Error, debes enviar dos números a la función
								</td>
							</tr>
						</table>
						<br>
						<p>
							Como se puede ver en el código anterior, se indica el final de la función luego de la sentencia print, usando <br>
							la sentencia return aunque no devuelva nada, ya que en este caso se utiliza para finalizar la ejecución de la <br>
							llamada a la función y "devolver" el resultado que en este caso no está definido por lo que será el valor por <br>
							defecto (None). <br>
							Tener en cuenta que las declaraciones posteriores a las declaraciones de devolución no se ejecutan.
						</p>
						<p>
							Los valores de un parámetro por defecto pueden ser de cualquier tipo, así que retomando el ejemplo de <br>
							mi_funcion, podemos asignar diferentes valores por defecto a los parámetros: 
							<table>
								<tr>
									<th>Código</th>
								</tr>
								<tr>
									<td>
										Imprimir los valores pasados como parámetro. <br>
										<strong style="color: red;">def</strong> mi_funcion(param1 = <strong style="color: green;">"Hola"</strong>, param2 = <strong style="color: red;">0</strong>): 
										<ul>
											<strong style="color: green;">"""Esta función imprime los dos valores pasados como parámetros"""</strong> <br>
											<strong style="color: blue;">print</strong>(param1) <br>
											<strong style="color: blue;">print</strong>(param2)
										</ul>
										<br>
										<strong>mi_funcion()</strong>
									</td>
								</tr>
								<tr>
									<th>Resultado</th>
								</tr>
								<tr>
									<td>
										Hola <br>
										0
									</td>
								</tr>
							</table>
						</p>
					</li>
					<li>
						<strong style="color: cornflowerblue;">Argumentos indeterminados</strong><br>
						En alguna acasión no podremos determinar previamente cuantos elementos se necesita enviar <br>
						a una función. En estos casos se puede utilizar los <strong>argumentos indeterminados</strong> por posición y <br>
						por nombre.
						<ul>
							<li>
								<strong style="color: cornflowerblue;">Por posición</strong><br>
								Se debe crear una lista dinámica de argumentos, es decir, un tipo tupla, definiendo el <br>
								parámetro con un asterisco, para recibir los parámetros indetermiandos por posición:
								<table>
									<tr>
										<th>Código</th>
									</tr>
									<tr>
										<td>
											Imprimir los valores pasados como parámetro. <br><br>
											<strong style="color: red;">def</strong> indeterminados(*args): 
											<ul>
												<strong style="color: green;">"""Esta función imprime los valores pasados como parámetro"""</strong> <br>
												<strong style="color: red;">for</strong> arg <strong style="color: blue;">in</strong> args:
												<ul>
													<strong style="color: blue;">print</strong>(arg)
												</ul>
											</ul>
											<br>
											<strong>Indeterminados(<strong style="color: red;">5</strong>,<strong style="color: green;">"Hola"</strong>, [<strong style="color: red;">1, 2, 3, 4, 5</strong>] )</strong>
										</td>
									</tr>
									<tr>
										<th>Resultado</th>
									</tr>
									<tr>
										<td>
											5 <br>
											Hola <br>
											[1, 2, 3, 4, 5]
										</td>
									</tr>
								</table>
								Esta sintaxis funciona creando una tupla en la que se almacenan los valores de todos los parámetros <br>
								extra pasados como argumento. Para el caso de que se llame a la función sin parámetros, la tupla estaría <br>
								vacía, por lo tanto no se imprimiría nada. En la llamada a la función que se hace en el ejemplo se crea una <br>
								tupla con los valores (5, "Hola", [1, 2, 3, 4, 5]).
							</li>
							<li>
								<strong style="color: cornflowerblue;">Por nombre</strong><br>
								Para recibir un número indeterminado de parámetros por nombre (clave-valor o en inglés Keyword args), <br>
								se debe crear un diccionario dinámico de argumentos definiendo el parámetro con dos asteristicos. <br>
								Las claves de este diccionario serían los nombres de los parámetros indicados al llamar a la función y <br>
								los valores del diccionario, los valores asociados a estos parámetros: 
								<table>
									<tr>
										<th>Código</th>
									</tr>
									<tr>
										<td>
											Imprimir los valores pasados como parámetro. <br><br>
											<strong style="color: red;">def</strong> indeterminados(**kwargs):
											<ul>
												<strong style="color: green;">"""Esta función los valores pasados como parámetro"""</strong><br>
												<strong style="color: blue;">print</strong>(kwargs)
											</ul>
											<br>
											<strong>indetermiandos(n= <strong style="color: red;">5</strong>, c=<strong style="color: green;">"Hola"</strong>, l= [<strong style="color: red;">1, 2, 3, 4, 5</strong>] )</strong>
										</td>
									</tr>
									<tr>
										<th>Resultado</th>
									</tr>
									<tr>
										<td>
											{'n' : 5, 'c' : 'Hola', 'l' : [1, 2, 3, 4, 5]}
										</td>
									</tr>
								</table>
								Al recibirse como un diccionario, puede iterarlo y mostrar la clave y valor de cada argumento:
								<table>
									<tr>
										<th>Código</th>
									</tr>
									<tr>
										<td>
											Imprimir los valores pasados como parámetro. <br><br>
											<strong style="color: red;">def</strong> indetermianados(**kwargs):
											<ul>
												<strong style="color: green;">"""Esta función imprime los valores pasados como parámetros"""</strong><br><br>
												<strong style="color: red;">for</strong> kwarg <strong style="color: blue;">in</strong> kwargs: 
												<ul>
													<strong style="color: blue;">print</strong>(kwarg, "=>", kwargs[kwarg])
												</ul>
											</ul>
											<strong>indetermianados(n= <strong style="color: red;">5</strong>, c= <strong style="color: green;">"Hola"</strong>, l= [<strong style="color: red;">1, 2, 3, 4, 5</strong>] )</strong>
										</td>
									</tr>
									<tr>
										<th>Resultado</th>
									</tr>
									<tr>
										<td>
											n => 5 <br>
											c => Hola <br>
											l => [1, 2, 3, 4, 5]
										</td>
									</tr>
								</table>
							</li>
							<li>
								<strong style="color: cornflowerblue;">Por posición y nombre</strong><br>
								Si requiere aceptar ambos tipos de parámetros simultáneamente en una función, entonces debe <br>
								crear ambas colecciones dinámicas. Primero los argumentos indeterminados por valor y luego <br>
								los cuales son por clave y valor:
								<table>
									<tr>
										<th>Código</th>
									</tr>
									<tr>
										<td>
											Imprimir los valores pasados como parámetros por posición y nombre. <br><br>
											<strong style="color: red;">def</strong> super_funcion(*args, **kwargs):
											<ul>
												<strong style="color: green;">"""Esta función imprime los valores pasados como parámetro por posición y nombre"""</strong><br><br>
												<strong>total = 0</strong><br>
												<strong style="color: red;">for</strong> arg <strong style="color: blue;">in</strong> args: 
												<ul>
													<strong>total += arg</strong>
												</ul>
												<strong style="color: blue;">print</strong>("Total", "=>", <strong>total</strong>) <br><br>
												<strong style="color: red;">for</strong> kwarg <strong style="color: blue;">in</strong> kwargs:
												<ul>
													<strong style="color: blue;">print</strong>(kwarg, "=>", kwargs[kwarg])
												</ul>
												<br><br>
												<strong>super_funcion(<strong style="color: red;">50, -1, 1.56, 10, 20, 300</strong>, c= <strong style="color: green;">"Hola"</strong>, n= <strong style="color: red;">3</strong> )</strong>
											</ul>
										</td>
									</tr>
									<tr>
										<th>Resultado</th>
									</tr>
									<tr>
										<td>
											Total => 380.56 <br>
											c => Hola <br>
											n => 3 
										</td>
									</tr>
								</table>
								Los nombres <strong>args</strong> y <strong>kwargs</strong> no son obligatorios, pero se suelen utilizar por convención. <br>
								Muchos frameworks y librerías los utilizan por lo que es buena práctica llamarlos así.
							</li>
						</ul>
					</li>
				</ul>
			</center>
		</article>
		<article class="post" >
			<center>
				<h2>Paso de argumentos por referencia y por valor</h2>
				<p>
					Si conoces algún lenguaje de programación te estarás preguntando si <strong>en Python al pasar <br>
					una variable como argumento de una función estas se pasan por referencia o por valor.</strong>
				</p>
				<p>
					En el <strong>paso por referencia</strong> lo que pasa como argumento es una <strong>referencia o puntero a la <br>
					variable</strong>, es decir, la dirección de memoria en la que se encuentra el contenido de la variable, y no <br>
					el contenido en sí. En el <strong>paso por valor</strong>, por el contrario, lo que se pasa como argumento es el <br>
					valor que contenía la variable. 
				</p>
				<p>
					Pero en resumen, <strong>la diferencia entre ambos es que en el <strong style="color: blue;">paso por valor</strong> los cambios que se <br>
					hagan sobre el parámetro no se ven fuera de la función, dado que los argumentos de la función son variables locales a la función, que contienen <br>
					los valores indicados por las variables que se pasaron como argumento.</strong> Es decir, en realidad lo que se le pasa a la función son copias de <br>
					los valores y no las variables en sí.
				</p>
				<p>
					<strong>
						Si quisiéramos modificar el valor de uno de los argumentos y que estos cambios se reflejarán <br>
						fuera de la función tendríamos que pasar el parámetro por referencia. 
					</strong>
				</p>
				<p>
					En C los argumentos de las funciones se pasar por valor, aunque se pueda simular el paso por referencia usando punteros. <br>
					En Java también se usa paso por valor, aunque para las variables que son objetos lo que se hace es pasar por valor la <br>
					referencia al objeto, por lo que en realidad parece paso por referencia.
				</p>
				<p>
					En Python también se utiliza el paso por valor de referencias a objetos, como en Java, aunque en el caso de Python, a <br>
					diferencia de Java, <strong>todo es un objeto</strong> (para ser exactos lo que ocurre en realidad es que al objeto se le <br> 
					asigna otra etiqueta o nombre en el espeacio de nombres local de la función).
				</p>
				<p>
					Sin embargo <strong>no todos los cambios que hagamos a los parámetros dentro de una función Python se reflejarán fuera de esta</strong>, <br>
					ya que hay que tener en cuenta que en Python existen objetos inmutables, como las tuplas, por lo que si intentáramos modificar una tupla <br>
					pasada como parámetro lo que ocurriría en realidad es que se crearía una nueva instancia, por lo que los cambios no se verían fuera de la función.
				</p>
				<p>
					Veamos con este ejemplo que hace uso del método append de las listas. Un método no es más que una función que pertenece <br>
					a un objeto, en este caso a una lista; y append, en concreto, sirve para añadir un elemento a una lista.
				</p>
				<br>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Modificar el valor de los elementos pasados como parámetro. <br><br>
							<strong style="color: red;">def</strong> funcion(x, y): 
							<ul>
								<strong style="color: green;">"""Esta función actualiza los valores de los argumentos pasados como parámetros"""</strong><br><br>
								<strong>
									x = x + 3 <br>
									y.append(23)
								</strong> <br>
								<strong style="color: blue;">print</strong>(x, y)
							</ul>
							<strong>x = <strong style="color: red;">22</strong></strong><br>
							<strong>y = [<strong style="color: red;">22</strong>]</strong><br>
							<strong>funcion(x, y)</strong><br>
							<strong style="color: blue;">print</strong>(x, z) 
							<br>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							25 [22, 23] <br>
							22 [22, 23]
						</td>
					</tr>
				</table>
				<br><br>
				<p>
					En el desarrollo y ejecución de funciones tendremos que tener en cuenta que los tipos de datos <br>
					inmutables conservarán su valor original (estos son los tipos simples de datos: String, Integer, <br> 
					Float, Boolean, etc), sin embargo, los mutables que son estructuras de datos más "complejas"(como: <br>
					dict, list, etc.) conservan los cambios hechos dentro de la función. Debido a esto podemos ver como <br>
					en el ejemplo anterior la <strong>variable x</strong> no conserva los cambios una vez salimos de la <br>
					función y la <strong>lista y</strong> si los conserva, porque las listas son mutables. <br><br>
					En resumen:
				</p>
				<img src="{% static 'img/parablog44.jpg'%}">
				<br><br>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Asignación de variables locales y globales</h3>
				<p>
					Todas las <strong>asignaciones de variables</strong> en la función almecenan el valor en la <strong>tabla de símbolos <br>
					local;</strong> así mismo la referencia a variables primero mira la <strong>tabla de símbolos local</strong>, luego en la <br>
					tabla de símbolos local de las funciones externas, luego la tabla de símbolos global, y finalmente la tabla de nombres <br>
					predefinidos. Así, no se les puede asignar directamente un valor a las variables globales dentro de una función (a menos <br>
					se las nombre en la sentencia global), aunque sí pueden ser referenciadas.
				</p>
				<img src="{% static 'img/parablog45.jpg'%}" alt="Info-Python-blog">
				<br><br>
				<p>
					Los <strong>parámetros reales</strong> (argumentos) de una función se introducen en la tabla de símbolos local <br>
					de la función llamada cuando esta es ejecutada; así, los argumentos son pasados por valor (donde el valor es siempre <br> 
					una referencia a un objeto, no el valor del objeto).
				</p>
				<p>
					Cuando una función llama a otra función, una nueva tabla de símbolos local es creada para esa llamada.
				</p>
				<p>
					La definición de una función introduce el nombre de la función en la tabla de símbolos actual. <br>
					El valor del nombre de la función tiene un tipo que es reconocido por el interprete como una función <br>
					definida por el usuario. Este valor puede ser asignado a otro nombre que luego puede ser usado como una función. <br>
					Esto sirve como un mecanismo general para renombrar.
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Crear una función que actualice el valor de una variable inmutable. <br><br>
							<strong>mi_variable_global_1 = <strong style="color: red;">20</strong></strong><br>
							<strong>mi_variable_global_2 = <strong style="color: red;">20</strong></strong><br><br>
							<strong style="color: red;">def</strong> <strong>funcion():</strong>
							<ul>
								<strong style="color: green;">"""Esta función actualiza el valor de una variable global de tipo inmutale"""</strong><br>
								<strong style="color: red;">global</strong> <strong>mi_variable_global_1</strong><br>
								<strong>mi_variable_global_1 = <strong style="color: red;">10</strong></strong><br>
								<strong>mi_variable_global_2 = <strong style="color: red;">10</strong></strong>
							</ul>
							<br><br>
							<strong>funcion()</strong><br>
							<strong style="color: blue;">print</strong><strong>(mi_variable_global_1)</strong> <br>
							<strong style="color: blue;">print</strong><strong>(mi_variable_global_2)</strong>
							<br><br>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							10 <br>
							20 
						</td>
					</tr>
				</table>
			</center>
		</article>
		<article class="post">
			<br>
			<center>
				<h3 style="color: cornflowerblue;">Sentencia pass</h3>
				<p>
					Es una <strong>operación nula</strong>, lo que quiere decir que cuando es ejecutada nada sucede. Eso es útil <br>
					como un contenedor cuando una sentencia es requerida sintácticamente, pero no necesita código que ser ejecutado, <br>
					por ejemplo:
				</p>
				<table style="width: 46%;">
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Ejemplo de utilización de la sentencia pass. <br><br>
							<strong style="color: red;">def</strong> <strong>consultar_nombre_genero(genero):</strong>
							<ul>
								<strong style="color: green;">"""Es una función que no hace nada aun"""</strong><br>
								<strong style="color: red;">pass</strong>
							</ul>
							<br>
							<strong style="color: red;">class</strong> <strong>Persona():</strong>
							<ul>
								<strong style="color: green;">"""Es una clase sin métodos o atributos aun"""</strong><br>
								<strong style="color: red;">pass</strong>
							</ul>
							<strong style="color: blue;">print</strong><strong>(<strong style="color: blue;">type</strong><strong>(consultar_nombre_genero)</strong>)</strong><br>
							<strong>consultar_nombre_genero(<strong style="color: green;">"M"</strong>)</strong> <br>
							<strong>persona1 = Persona</strong><br>
							<strong style="color: blue;">print</strong><strong>(<strong style="color: blue;">type</strong><strong>(persona1)</strong>)</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							class 'function'> <br>
							class 'type'> 
						</td>
					</tr>
				</table>
			</center>
		</article>
		<article class="post">
			<br>
			<center>
				<h3 style="color: cornflowerblue;">Sentencia return</h3>
				<p>
					Las funciones pueden comunicarse con el exterior de las mismas, al proceso principal del programa <br>
					usando la sentencia return. El proceso de comunicación con el exterior se hace devolviendo valores. <br>
					A continuación, un ejemplo de función usando return:
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Dado dos números calcular la suma de ambos números. <br><br>
							<strong style="color: red;">def</strong> <strong>suma(x, y):</strong>
							<ul>
								<strong style="color: green;">"""Esta función imprime la suma de los dos valores pasados como parámetro"""</strong><br>
								<strong style="color: red;">return</strong> <strong>x + y</strong>
							</ul>
							<strong style="color: blue;">print</strong> <strong>(suma(<strong style="color: red;">27</strong>, <strong style="color: red;">89</strong>))</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							116
						</td>
					</tr>
				</table>
				<br>
				<p>
					Una característica interesante, es la posibilidad de devolver valores múltiples separados por <br>
					comas:
				</p>
				<table style="width: 44%;">
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Crear una función que retorne varios valores. <br><br>
							<strong style="color: red;">def</strong> <strong>prueba():</strong>
							<ul>
								<strong style="color: green;">"""Esta función retorna varios valores"""</strong><br>
								<strong style="color: red;">return</strong> <strong style="color: green;">"Hola"</strong>, <strong style="color: red;">20</strong>, <strong>[<strong style="color: red;">1, 2, 3</strong>]</strong>
							</ul>
							<strong style="color: blue;">print</strong> <strong>(prueba())</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							('Hola', 20, [1, 2, 3])
						</td>
					</tr>
				</table>
				<p>
					Sin embargo no se trata de que las funciones Python puedan devolver varios valores, lo que ocurre <br>
					en realidad es que Python crea una tupla inmutable cuyos elementos son valores a retornar, y esta <br>
					única variable es la que se devuelve.
				</p>
				<table>
					<tr>
						<th>Código</th>
					</tr>
					<tr>
						<td>
							Crear una función que retorne varios valores y asignarlo a distintas variables. <br><br>
							<strong style="color: red;">def</strong> <strong>prueba():</strong>
							<ul>
								<strong style="color: green;">"""Esta función retorna varios valores"""</strong><br>
								<strong style="color: red;">return</strong> <strong style="color: green;">"Hola"</strong>, <strong style="color: red;">20</strong>, <strong>[<strong style="color: red;">1, 2, 3</strong>]</strong>
							</ul>
							<strong style="color: blue;">print</strong><strong>(prueba())</strong><br>
							<strong>x, y, z = prueba()</strong><br>
							<strong style="color: blue;">print</strong><strong>(x)</strong><br>
							<strong style="color: blue;">print</strong><strong>(y)</strong><br>
							<strong style="color: blue;">print</strong><strong>(z)</strong>
						</td>
					</tr>
					<tr>
						<th>Resultado</th>
					</tr>
					<tr>
						<td>
							('Hola', 20, [1, 2, 3]) <br>
							Hola <br>
							20 <br>
							[1, 2, 3]
						</td>
					</tr>
				</table>
				<br>
				<p>
					En el código anterior se muestra como asignar valores a distintas variables en base a la tupla <br>
					inmutable que retorna la función.
				</p>
			</center>
		</article>
		<article class="post">
			<center>
				<h3 style="color: cornflowerblue;">Llamadas de retorno</h3>
				<p>
					En Python, es posible (al igual que en la gran mayoría de los lenguajes de programación), llamar a una función <br>
					dentro de otra de forma fija y de la misma manera que se la llamaría desde fuera de dicha función.
				</p>
				<!--Sigue... una table de ejemplo-->
			</center>
		</article>
		<!--Sigue...-->
	</section>
</body>
</html>